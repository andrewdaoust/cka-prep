<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">Volumes and Data | CKA Prep</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/cka-prep/docs/fundamentals/chapter08"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Volumes and Data | CKA Prep"><meta data-react-helmet="true" name="description" content="Course Reading"><meta data-react-helmet="true" property="og:description" content="Course Reading"><link data-react-helmet="true" rel="icon" href="/cka-prep/img/k8s.png"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/cka-prep/docs/fundamentals/chapter08"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/cka-prep/docs/fundamentals/chapter08" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/cka-prep/docs/fundamentals/chapter08" hreflang="x-default"><link rel="stylesheet" href="/cka-prep/assets/css/styles.e68b4784.css">
<link rel="preload" href="/cka-prep/assets/js/runtime~main.96d354ef.js" as="script">
<link rel="preload" href="/cka-prep/assets/js/main.d9dff869.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/cka-prep/"><div class="navbar__logo"><img src="/cka-prep/img/kubernetes-icon.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/cka-prep/img/kubernetes-icon.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">CKA Prep</b></a><a class="navbar__item navbar__link navbar__link--active" href="/cka-prep/docs/intro">Notes</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/andrewdaoust/cka-prep" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cka-prep/docs/intro">Kubernetes Resources</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/cka-prep/docs/fundamentals">Kubernetes Fundamentals</a><button aria-label="Toggle the collapsible sidebar category &#x27;Kubernetes Fundamentals&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter01">Course Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter02">Basics of Kubernetes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter03">Installation and Configuration</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter04">Kubernetes Architecture</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter05">APIs and Access</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter06">API Objects</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter07">Managing State with Deployments</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/cka-prep/docs/fundamentals/chapter08">Volumes and Data</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter09">Services</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter10">Helm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter11">Ingress</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter12">Scheduling</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter13">Logging and Troubleshooting</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter14">Custom Resource Definitions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter15">Security</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter16">High Availability</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter17">Exam Domain Review</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/follow-up">Follow-up Items</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/cka-prep/docs/kubectl/setup">kubectl</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/cka-prep/docs/hard-way/about">Kubernetes the Hard Way</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/cka-prep/docs/linux">Linux</a><button aria-label="Toggle the collapsible sidebar category &#x27;Linux&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/cka-prep/docs/misc">Miscellaneous Topics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Miscellaneous Topics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Volumes and Data</h1></header><h2 id="course-reading">Course Reading</h2><h3 id="learning-objectives">Learning objectives</h3><ul><li>Understand and create persistent volumes</li><li>Configure persistent volume claims</li><li>Manage volume access modes</li><li>Deploy applications with persistent data storage</li><li>Discuss dynamic provisioning of storage</li><li>Configure secrets and ConfigMaps</li></ul><h3 id="overview">Overview</h3><p>Traditionally container engines do not offer storage that outlasts the container, since the container is seen as transient.  This could potentially lead to data loss or the need for complex data storage schemes.</p><p>In Kubernetes, <strong>volumes</strong> share the lifetime of a Pod, not the containers in them.  If a container terminates, the next one still has the data. Volumes are directories, sometimes pre-populated, that is made available to the containers in a Pod.  Volume creation, backend storage, and the data/contents is dependent on the type of volume, of which there are many, which you can <a href="https://kubernetes.io/docs/concepts/storage/volumes/#volume-types">read about here</a>, each with different configuration and dependencies.</p><p>There is an effort to adopt the Container Storage Interface (CSI) to reach an industry standard interface for container orchestration to allow access to arbitrary storage systems. Currently, all volume plug-ins are &quot;in-tree&quot;, meaning they are built with the Kubernetes source code. A swap to an &quot;out-of-tree&quot; model means 3rd-parties just need to develop their own driver to allow their plugin to be containerized, replacing the Flex plugin which has major security concerns.</p><p>Sometimes you may also want the storage to have a lifetime that exceeds a Pod as well, and for this <strong>persistent volumes</strong> are used.  These allow volumes to out live Pods, and then be claimed by Pods with a Persistent Volume Claim. If one Pod is terminated, another one can come along and claim the persistent volume.</p><p>Two API object previously seen to pass data to Pods are ConfigMaps (for non-encoded data) and Secrets (for encoded data). These two object let you easily pass things like SSH keys, passwords, or configuration to the Pods, just to name a few use cases.</p><h3 id="introducing-volumes">Introducing volumes</h3><p><img alt="object relationship" src="/cka-prep/assets/images/ch08-volumes-097df45e32ceb3ddad83983a737d6e34.png" width="2550" height="3300"></p><p>Volumes can be defined in podSpec and where they are made available.  Each volume configuration requires a name, type, and mount point.One volume can be made available to multiple containers within the Pod, and this can be used as method of communication between containers.  Volumes can also be made available to multiple Pods, and each Pod has access to write to the volume.  Volumes have no concurrency checking, so the potential for corruption when enabling a volume for access from multiple Pods is high unless there is an outside mechanism to lock changes when others are in progress.</p><p>An access mode is part of the Pod request. As a request, more access may be granted, but not less, and an exact match is attempted to be made.  The cluster groups all the volumes from the requested mode and sorts from smallest to largest.  The claim is then checked against the list for the mode until one of sufficient size is found.  There are three access modes.:</p><ul><li><strong>ReadWriteOnce</strong> allows read-write by a single node</li><li><strong>ReadOnlyMany</strong> allows read only access by multiple nodes</li><li><strong>ReadWriteMany</strong> allows read-write access by multiple nodes</li></ul><p>Two Pods on the same node can write to a volume that has a ReadWriteOnce access mode, but a Pod on another node would not become ready if trying to attach to that volume due to a <code>FailedAttachVolume</code> error.</p><p>When a volume is requested, the local kubelet run the <code>kubelet_pods.go</code> script to get a map of all the devices, determine and create mount points for containers, and then create the symlink on the host node file system to associate the storage to the container.  The API server requests the storage from the <code>StorageClass</code> plugin.</p><p>If a request for a StorageClass was not made, only the parameters for access mode and size will be used. The volume could come from any of the storage options available, there is no configuration to determine which of the available will be used.</p><h3 id="volume-spec">Volume spec</h3><p>On of many types of storage options in Kubernetes is the <code>emptyDir</code>. The kubelet creates a directory in the container, but does not mount any storage.  Any data is written to the shared container space, and as a result is not persistent. When a Pod is destroyed, the data is deleted with the container.</p><pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir: {}
</code></pre><p>The YAML above creates a single container Pod with a volume, named <code>cache-volume</code>, which would be created in the <code>/cache</code> directory in the container.</p><h3 id="volume-types">Volume types</h3><p>There are quite a few different volume type that can be used, some using local storage, others using networked resources.</p><p>For GCE, AWS, and Azure, there were the <code>gcePersistentDisk</code>, <code>awsElasticBlockStore</code>, and <code>azureDisk</code> and <code>azureFile</code>, all of these not being depreciated, replaced with new out-of-tree plugins being in alpha or beta that use the new CSI features.</p><p>There are <code>emptyDir</code> and <code>hostPath</code> volumes which are easy to use. The <code>emptyDir</code> was already discussed. The <code>hostPath</code> volume type mounts a resource from the host node filesystem. The resource could be a directory, file socket, character, or block device.  The resource must already exist on the host to be used, and there are two types, <code>DirectoryOrCreate</code> and <code>FileOrCreate</code>, which create the resource on the host and then use them if they do not exist already.</p><p>For scenarios with multiple readers a network file system (<code>nfs</code>) or a Internet Small Computer System Interface (<code>iscsi</code>) are easy choices.</p><p>For multiple writers good choices are <code>rdb</code> for a block storage option, or <code>cephfs</code> or <code>glusterfs</code> if either are configured on the cluster.</p><p>All available volume types can be read about on the official <a href="https://kubernetes.io/docs/concepts/storage/volumes/">Kubernetes docs page</a>.</p><p>The CSI allows for more flexibility and decoupling plugins from the Kubernetes source code. It exists so that arbitrary plugins can be exposed more easily in the future.</p><h3 id="shared-volume-example">Shared volume example</h3><pre><code class="language-yaml">...
  containers:
  - name: alphacont
    image: busybox
    volumeMounts:
    - mountPath: /alphadir
      name: sharevol
  - name: betacont
    image: busybox
    volumeMounts:
    - mountPath: /betadir
      name: sharevol
  volumes:
  - name: sharevol
    emptyDir: {} 
</code></pre><p>The snipping from the YAML above would produce a Pod named <code>exampleA</code> that has two containers both with access to a volume, <code>sharevol</code>. An <code>emptyDir</code> or <code>hostPath</code> could both easily be used here since both require no additional setup.</p><p>If the Pod was created and then the following commands are run</p><pre><code class="language-bash">kubectl exec -it exampleA -c betacont -- touch /betadir/foobar
kubectl exec -it exampleA -c alphacont -- ls -l /alphadir
</code></pre><p>you should see a <code>foobar</code> file in the <code>alphadir</code> even though the other container wrote the data.  The containers have immediate access to any data the either of them write to the shared volume, and there is nothing stopping them from overwriting each others data. Locking or versioning of the data written by the containers must be considered and implemented into the containerized application to avoid issues with corrupted data.</p><h3 id="persistent-volumes-and-claims">Persistent volumes and claims</h3><p>A persistent volume (pv) is another storage abstraction used to give data a lifetime that exceeds that of a Pod. Pods define a volume that used the type <code>persistentVolumeClaim</code> (<code>pvc</code>). The pvc has various parameters to define the size and the type of backend storage, known as the <code>StorageClass</code>.  The cluster then attached the <code>persistentVolume</code>.  The cluster will dynamically use volumes that are available, irrespective of the storage type, allowing the claims to use ay backend storage.</p><h4 id="phases-of-persistent-storage">Phases of persistent storage</h4><p><strong>Provisioning</strong> of the persistent volumes can take a few forms. For example, they could be defined ahead of time by the administrator of the cluster, or they might dynamically be created, say by a request from a cloud provider.</p><p>A <strong>binding</strong> operation occurs when a watch loop see a new PVC, which contains the storage size, access request, and optionally, a <code>StorageClass</code>.  The controller locates a PV that matches this request, or it may have to wait for the <code>StorageClass</code> provisioner to create a new one.  The PV must meet the requested storage size, but it could contain more if only larger PV are available.</p><p><strong>Use</strong> of the PV begins when the volume is mounted to a Pod and continues through the lifetime of that Pod.</p><p>When the Pod is done with the volume and an API request is sent, the PVC is deleted and the volume is said to be <strong>released</strong>.  The volume remains in the same state from when the claim was deleted until it available to a new claim.  The data on the volume is retained depending on the defined <code>persistentVolumeReclaimPolicy</code>.</p><p>Volumes are <strong>reclaimed</strong> when one of three options happen:</p><ul><li>A <strong>retain</strong>, which keeps the data and allows the admin to handle the storage and data.</li><li>A <strong>delete</strong>, removing the API object and the associated storage.</li><li>A <strong>recycle</strong>, which runs a <code>rm -rf /mountpoint</code> and then makes the volume available to a new claim.  With dynamic provisioning reaching good stability, this is intended to be depreciated.</li></ul><p>Like with other API object, PVs and PVCs can be viewed and described with <code>kubectl</code>.</p><pre><code class="language-bash">kubectl get pv
kubectl get pvc
</code></pre><h3 id="persistent-volume">Persistent Volume</h3><p>Here is a basic example of a PV declaration that uses a <code>hostPath</code> as the storage type.</p><pre><code class="language-yaml">kind: PersistentVolume
apiVersion: v1
metadata:
  name: 10Gpv01
  labels: 
    type: local 
spec:
  capacity: 
    storage: 10Gi
  accessModes:
  - ReadWriteOnce
  hostPath:
    path: &quot;/somepath/data01&quot;
</code></pre><p>Each storage type has its own configuration settings.  An example would be a Ceph or GE Persistent Disk that already exists, so it would not need to be configured and would just need to be claimed from the provider.</p><p>PVs are not namespaced objects, but PVCs are. Stable as of v1.18, Raw Block Volumes are allowed to be statically provisioned, supporting a handful of different volume plugins, which you can find <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#raw-block-volume-support">an up-to-date list of here</a>.</p><p>Locally attached storage is also a stable feature, often used as a part of distributed file systems or for databases.</p><h3 id="persistent-volume-claim">Persistent Volume Claim</h3><p>Once a PV has been created in the cluster, a manifest for a claim can be written and the claim used by a Pod definition.  In the Pod, the volume is a <code>persistentVolumeClaim</code>.</p><pre><code class="language-yaml" metastring="title={Persistent Volume Claim manifest}" title="{Persistent">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myclaim
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 8GI
</code></pre><pre><code class="language-yaml" metastring="title={Pod manifest using PVC}" title="{Pod">...
  spec:
    containers:
    ...
    volumes:
    - name: test-volume
      persistentVolumeClaim:
        claimName: myclaim
</code></pre><p>That example is rather simple. A more complex configuration might look like</p><pre><code class="language-yaml" metastring="title={Complex PVC usage}" title="{Complex">...
  volumeMounts:
  - name: Cephpd
    mountPath: /data/rbd
  volumes:
  - name: rbdpd
    rbd:
      monitors:
      - &#x27;10.19.14.22:6789&#x27;
      - &#x27;10.19.14.23:6789&#x27;
      - &#x27;10.19.14.24:6789&#x27;
      pool: k8s
      image: client
      fsType: ext4
      readOnly: true
      user: admin
      keyring: /etc/ceph/keyring
      imageformat: &quot;2&quot;
      imagefeatures: &quot;layering&quot;
</code></pre><h3 id="dynamic-provisioning">Dynamic provisioning</h3><p>Using persistent volumes and abstracting that storage with a claim were very powerful, but it originally required an administrator to create them.  Starting in Kubernetes v1.4, dynamic provisioning was added so that a cluster could request storage from an external, pre-configured source.  </p><p>The <code>StorageClass</code> API resources lets admins define a persistent volume provisioner. This is of a certain type with storage specific configuration.  Once created, users can request a claim from the <code>StorageClass</code>, and the API fills this via auto-provisioning. The resource will be reclaimed as configured by the provider.  Common choices from dynamic storage are AWS and GCE, and there are other options like a Ceph cluster or iSCSI.</p><p>This is an example of an AWS <code>StorageClass</code> using gp2 storage:</p><pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: gp2
  annotations:
    storageclass.kubernetes.io/is-default-class: &quot;true&quot;
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
  fsType: ext4
</code></pre><h3 id="using-rook-for-storage-orchestration">Using Rook for storage orchestration</h3><p>Rook is a project that allows for orchestration of storage by multiple providers. As with other agents within Kubernetes, Rook uses custom resource definitions (CRD) and a custom operator to handle the provisioning of storage according to backend storage type.  Currently several storage providers are supported, such as Ceph, Cassandra, and Network File System (NFS).</p><p>You can learn more about the project <a href="https://rook.io/">here</a>.</p><h3 id="secrets">Secrets</h3><p>For data you don&#x27;t want readable to the naked eye, like a password, you can use secrets. Secret API resources can take this data and encode or encrypt it so it is not easily readable.</p><p>You can create, get, and delete secrets like so:</p><pre><code class="language-bash">kubectl create secret generic --help
kubectl create secret generic mysql --from-literal=password=root
kubectl get secrets
kubectl delete secret mysql
</code></pre><p>Secrets are not encrypted by default, but instead are base64 encoded. To encrypt secrets you must create an <code>EncryptionConfiguration</code> with a key and proper identity.  Then the kube-apiserver needs to have the <code>--encryption-provider-flag</code> enabled to a previously configured provider (e.g. <code>aescbc</code> or <code>ksm</code>). Once enabled, every secret must be recreated since the encryption happens on the write.</p><p>You can have multiple keys, each is tried during decryption.  The first key of the first provider is used to encrypt secrets. To rotate them, create a new key, restart all kube-apiserver processes, and then recreate all secrets.</p><p>The encoded string in the secret can be viewed with <code>kubectl</code>.  The secret is decoded and saved as a string to file, which can be used as an environment variable or in a new directory, similar to how a volume is mounted.</p><p>Secrets can be made manually with a manifest as well by pasting the encoded string into the manifest.  Here is an example:</p><pre><code class="language-bash">echo LFTr@1n | base64
vim secret.yaml
</code></pre><pre><code class="language-yaml" metastring="title={secret.yaml}" title="{secret.yaml}">apiVersion: v1
kind: Secret
metadata:
  name: lf-secret
data:
  password: TEZUckAxbgo=
</code></pre><p>where the output of the <code>echo</code> command is entered as the <code>password</code> value.</p><h3 id="using-secrets-via-environment-variables">Using secrets via environment variables</h3><p>You can configure a secret as an environment variable for a Pod in a manifest like so:</p><pre><code class="language-yaml">...
  spec:
    containers:
    - image: mysql:5.5
      name: dbpod
      env:
      - name: MYSQL_ROOT_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysql
            key: password
</code></pre><p>There is not a limit to the number of secrets used, but a secret can only be up to 1 MB in size.  Secrets, just like any other API object, takes up memory, so with large numbers you can deplete memory on a node.</p><p>Secrets are stored in <code>tmpfs</code> storage on the host node, and only get sent to the host Pod.  All volumes that a Pod request must exist before containers are started, secrets are no different.</p><h3 id="mounting-secrets-as-volumes">Mounting secrets as volumes</h3><p>Secrets can also be mounted as files using volume definitions.  The mount path contains a file with the name of the secret.</p><pre><code class="language-yaml">...
  spec:
    containers:
    - image: busybox
      command:
        - sleep
        - &quot;3600&quot;
      volumeMounts:
      - mountPath: /mysqlpassword
        name: mysql
      name: busy
    volumes:
    - name: mysql
        secret:
          secretName: mysql
</code></pre><p>Once the Pod is up and running, you can verify a secret is accessible with</p><pre><code class="language-bash">kubectl exec -it busybox -- cat /mysqlpassword/password
</code></pre><h3 id="portable-data-with-configmaps">Portable data with ConfigMaps</h3><p>ConfigMaps are similar to secrets, but the data they contain is not encoded.  ConfigMaps decouple a container image from their configuration artifacts (and this fits well with Kubernetes model of decoupling). Data is stored as key-value pairs or plain configuration files of any format, and it can come from a collection of files or all files in a directory. ConfigMaps can also be populated from a literal value.</p><p>Here&#x27;s an example of how you might use a ConfigMap.  Assume you have a YAML (or any other file type) configuration file on your local machine. You can create a <code>configmap</code> object that contains this data. The <code>data</code> section of the ConfigMap will contain the configuration when you view the object.</p><pre><code class="language-bash">kubectl get configmap envyaml -o yaml
</code></pre><pre><code class="language-yaml">kind: ConfigMap
apiVersion: v1
metadata:
  name: envyaml
data:
  env.yaml: |
    ...
</code></pre><p>ConfigMaps are consumed in multiple ways:</p><ul><li>Pod environment variables from one or many ConfigMaps</li><li>For Pod commands</li><li>Populate a volume, or add ConfigMap data to specific path within a volume</li><li>Set file names and access modes in a volume</li><li>Use by system components or controllers</li></ul><h3 id="using-configmaps">Using ConfigMaps</h3><p>Like secrets, Configmaps must exist prior to use (unless they are marked as optional) and are namespace dependent.</p><p>Let&#x27;s first look at the use case of setting an environment variable. The manifest defining the Pods will use a <code>valueFrom</code> key and a <code>configMapKeyRef</code> value to get the data from the ConfigMap.</p><pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: envar-demo
spec:
  containers:
  - name: envar-demo-container
    env:
    - name: ENVIRON_VAR_VALUE
      valueFrom:
        configMapKeyRef:
          name: some-config
          value: someconfig.how
</code></pre><p>Now let&#x27;s look at creating a volume with a ConfigMap.</p><pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: configmap-volunes
spec:
  volumes:
  - name: config-volume
    configMap:
      name: some-config
</code></pre><h2 id="lab-exercises">Lab Exercises</h2><h3 id="lab-81---create-a-configmap">Lab 8.1 - Create a ConfigMap</h3><p>ConfigMaps can ingest data in 3 ways, from a literal value, from files, or from directories.  Let&#x27;s start by creating some data to ingest into a ConfigMap via file and directory.</p><pre><code class="language-bash">mkdir primary
echo c &gt; primary/cyan
echo m &gt; primary/magenta
echo y &gt; primary/yellow
echo k &gt; primary/black
echo &quot;known as key&quot; &gt;&gt; primary/black
echo blue &gt; favorite
</code></pre><p>And now let&#x27;s create a ConfigMap with this data using all three types of data ingestion.</p><pre><code class="language-bash">kubectl create configmap colors \
    --from-literal=text=black \  # Using a literal value
    --from-file=./favorite \     # Using a file
    --from-file=./primary/       # Using a directory
</code></pre><p>Now let&#x27;s view the ConfigMap in the cluster.</p><pre><code class="language-bash">kubectl get configmap colors
kubectl get configmap color -o yaml
</code></pre><p>With a ConfigMap successfully created, we can now use it in a Pod.</p><pre><code class="language-bash">vim simpleshell.yaml
</code></pre><pre><code class="language-yaml" metastring="title={simpleshell.yaml}" title="{simpleshell.yaml}">apiVersion: v1
kind: Pod
metadata:
  name: shell-demo
spec:
  containers:
  - name: nginx
    image: nginx
    env:
    - name: ilike
      valueFrom:
        configMapKeyRef:
          name: colors
          key: favorite
</code></pre><p>In this case we are using the ConfigMap to define an environment variable, <code>ilike</code>.  Now let&#x27;s create the Pod and check the variable&#x27;s value, the we can delete it.</p><pre><code class="language-bash">kubectl create -f simpleshell.yaml
kubectl exec shell-demo -- /bin/bash -c &#x27;echo $ilike&#x27;
kubectl delete pod shell-demo
</code></pre><p>All variables in a ConfigMap can be included as environment variables.  We cna replace the <code>env</code> section in our YAML manifest with an <code>envFrom</code>. Open the <code>simpleshell.yaml</code> in vim and change it to this:</p><pre><code class="language-yaml" metastring="title={simpleshell.yaml}" title="{simpleshell.yaml}">apiVersion: v1
kind: Pod
metadata:
  name: shell-demo
spec:
  containers:
  - name: nginx
    image: nginx
  #  env:
  #  - name: ilike
  #    valueFrom:
  #      configMapKeyRef:
  #        name: colors
  #        key: favorite
    envFrom:
    - configMapRef:
        name: colors
</code></pre><p>Then create the Pod and check the environment variables. You should see <code>black</code>, <code>cyan</code>, <code>yellow</code>, <code>text</code>, <code>favorite</code>, and <code>magenta</code> environment variables. Then you can delete the Pod again.</p><pre><code class="language-bash">kubectl create -f simpleshell.yaml
kubectl exec shell-demo -- /bin/bash -c &#x27;env&#x27;
kubectl delete pod shell-demo
</code></pre><p>ConfigMaps can also be defined in YAML. Let&#x27;s create a new one using that method.</p><pre><code class="language-bash">vim car-map.yaml
</code></pre><pre><code class="language-yaml" metastring="title={car-map.yaml}" title="{car-map.yaml}">apiVersion: v1
kind: ConfigMap
metadata:
  name: fast-car
  namespace: default
data:
  car.make: Ford
  car.model: Mustang
  car.trim: Shelby
</code></pre><p>Then we can create the ConfigMap and view it.</p><pre><code class="language-bash">kubectl create -f car-map.yaml
kubectl get configmap fast-car -o yaml
</code></pre><p>We&#x27;ll use this ConfigMap to mount it as as volume to a Pod.  We&#x27;ll reuse out <code>simpleshell.yaml</code>, open it and <code>vim</code> and edit it to match the new spec by removing the <code>env</code> and <code>envFrom</code> fields and adding in new <code>volumeMounts</code> and <code>volumes</code> configuration.</p><pre><code class="language-yaml" metastring="title={simpleshell.yaml}" title="{simpleshell.yaml}">apiVersion: v1
kind: Pod
metadata:
  name: shell-demo
spec:
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: car-vol
      mountPath: /etc/cars
  volumes:
  - name: car-vol
    configMap:
      name: fast-car
</code></pre><p>Now let&#x27;s create the Pod again and then inspect the mounted volume.</p><pre><code class="language-bash">kubectl create -f simpleshell.yaml
kubectl exec shell-demo -- /bin/bash -c &#x27;df -ha |grep car&#x27;
kubectl exec shell-demo -- /bin/bash -c &#x27;cat etc/cars/car.trim&#x27;
</code></pre><p>We can then delete the Pod and the ConfigMaps.</p><pre><code class="language-bash">kubectl delete pod shell-demo
kubectl delete configmap fast-car colors
</code></pre><h3 id="lab-82---create-a-persistent-nfs-volume-pv">Lab 8.2 - Create a persistent NFS volume (PV)</h3><p>To set up an NFS PV we first need an NFS server.</p><pre><code class="language-bash">sudo apt-get update &amp;&amp; sudo apt-get install -y nfs-kernel-server
</code></pre><p>Then we will make and populate a directory to be shared.</p><pre><code class="language-bash">sudo mkdir /opt/sfw
sudo chmod 1777 /opt/sfw
sudo bash -c &#x27;echo software &gt; /opt/sfw/hello.txt&#x27;
</code></pre><p>Now we will edit the NFS file server to share the new directory we created.  We will begin by sharing the directory to all but we can adjust this later if needed by using <code>snoop</code> to see the inbound request and then update to a more narrow scope.</p><pre><code class="language-bash">sudo vim /etc/exports
</code></pre><p>When <code>vim</code> opens, add the following line:</p><pre><code>/opt/sfw/ *(rw,sync,no_root_squash,subtree_check)
</code></pre><p>And then force the file to be re-read.</p><pre><code class="language-bash">sudo exportfs -ra
</code></pre><div class="admonition admonition-important alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Worker Node</h5></div><div class="admonition-content"><p>Now let&#x27;s switch to the worker node and test the NFS by mounting and inspecting it.</p><pre><code class="language-bash">sudo apt-get -y install nfs-common
showmount -e k8scp
sudo mount k8scp:/opt/sfw /mnt
ls -l /mnt
</code></pre><p>You should see the <code>hello.txt</code> file we created on the cp node.</p></div></div><p>Now back on the cp node, let&#x27;s create a YAML file to define the persistent volume. When defining a persistent volume in YAML, only syntax is checked, so any misspelling in a directory name will not cause an error, but the Pod will not start.  Note <code>accessModes</code> do not affect actual access and are usually used as labels.</p><pre><code class="language-bash">vim PVol.yaml
</code></pre><pre><code class="language-yaml" metastring="title={PVol.yaml}" title="{PVol.yaml}">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pvvol-1
spec:
  capacity:
    storage: 1Gi
  accessModes:
  - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  nfs:
    path: /opt/sfw
    server: k8scp
    readOnly: false
</code></pre><p>Then we can create the PV and check it was created.</p><pre><code class="language-bash">kubectl create -f PVol.yaml
kubectl get pv
</code></pre><h3 id="lab-83---creating-a-persistent-volume-claim-pvc">Lab 8.3 - Creating a persistent volume claim (PVC)</h3><p>First check to see if any PVCs exist.</p><pre><code class="language-bash">kubectl get pvc
</code></pre><p>Now define and then create a new PVC.</p><pre><code class="language-bash">vim pvc.yaml
</code></pre><pre><code class="language-yaml" metastring="title={pvc.yaml}" title="{pvc.yaml}">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-one
spec:
  accessModes:
  - ReadWriteMany
  resources:
    requests:
      storage: 200Mi
</code></pre><pre><code class="language-bash">kubectl create -f pvc.yaml
kubectl get pvc,pv
</code></pre><p>Notice when you got the PVC, it was 1Gi even though the request was for 200Mi. When you check the PV, you should now see the status as <code>BOUND</code>.</p><p>Now create a new Deployment that will use the PVC.  We can reuse one of our old deployments. We&#x27;ll update the name and add a <code>volumeMounts</code> and <code>volumes</code> section.  The <code>claimName</code> in the configuration must match an exist PVC.</p><pre><code class="language-bash">cp first.yaml nfs-pod.yaml
vim nfs-pod.yaml
</code></pre><pre><code class="language-yaml" metastring="title={nfs-pod.yaml}" title="{nfs-pod.yaml}">apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: &quot;1&quot;
  generation: 1
  labels:
    app: nginx
  name: nginx-nfs
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      run: nginx
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      creationTimestamp: null
      labels:
        run: nginx
    spec:
      containers:
      - image: nginx
        imagePullPolicy: Always
        name: nginx
        volumeMounts:
        - name: nfs-vol
          mountPath: /opt
        ports:
        - containerPort: 80
          protocol: TCP
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      volumes:
      - name: nfs-vol
        persistentVolumeClaim:
          claimName: pvc-one
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
</code></pre><p>Then, create the Pod and check its details. Also check the PVC, you should see it is <code>BOUND</code>.</p><pre><code class="language-bash">kubectl create -f nfs-pod.yaml
kubectl get pods
kubectl describe pod nginx-nfs-&lt;unique ID&gt;
kubectl get pvc
</code></pre><h3 id="lab-84---use-a-resourcequota-to-limit-pvc-count-and-usage">Lab 8.4 - Use a ResourceQuota to limit PVC count and usage</h3><p>Cloud storage often required limiting consumption by certain users because it is so flexible.  For this we will use a <code>ResourceQuota</code> to limit the total consumption and the number of PVCs.</p><p>First let&#x27;s delete the PV and PVC we created.</p><pre><code class="language-bash">kubectl get pv,pvc
kubectl delete deploy nginx-nfs
kubectl delete pvc pvc-one
kubectl delete pv pvvol-1
</code></pre><p>And then we will create a <code>ResourceQuota</code>.</p><pre><code class="language-bash">vim storage-quota.yaml
</code></pre><pre><code class="language-yaml" metastring="title={storage-quota.yaml}" title="{storage-quota.yaml}">apiVersion: v1
kind: ResourceQuota
metadata:
  name: storagequota
spec:
  hard:
    persistentvolumeclaims: &quot;10&quot;
    requests.storage: &quot;500Mi&quot;
</code></pre><p>Then we will create a new namespace, <code>small</code>, and describe it.</p><pre><code class="language-bash">kubectl create ns small
kubectl describe ns small
</code></pre><p>You&#x27;ll see it currently has no resource quota or limits. Then recreate the PV and PVC in the new namespace and then apply the new ResourceQuota and describe the namespace again.</p><pre><code class="language-bash">kubectl -n small create -f PVol.yaml
kubectl -n small create -f pvc.yaml
kubectl -n small create -f storage-quota.yaml
kubectl describe ns small
</code></pre><p>You should see it now has a ResourceQuota applied on the namespace. Now let&#x27;s edit the <code>nfs-pod.yaml</code> file from earlier and remove the <code>namespace</code> line from the metadata, and then recreate it in the new <code>small</code> namespace and verify it&#x27;s running.</p><pre><code class="language-bash">vim nfs-pod.yaml
kubectl -n small create -f nfs-pod.yaml
kubectl -n small get deploy
kubectl -n small describe deploy nginx-nfs
</code></pre><p>Then, get the Pods and describe the new Pod to make sure the NFS mounted volume is being used, and then check the quota on the namespace.</p><pre><code class="language-bash">kubectl -n small get pod
kubectl -n small describe pod nginx-nfs-&lt;unique ID&gt;
kubectl describe ns small
</code></pre><p>Now let&#x27;s create a 300M file in the /opt/sfw directory and then check the quota on the namespace again.</p><pre><code class="language-bash">sudo dd if=/dev/zero of=/opt/sfw/bigfile bs=1M count=300
kubectl describe ns small
du -h /opt/
</code></pre><p>You should see the quota is unchanged. With the NFS, the size of the shared file does not count against the deployment. Now let&#x27;s demonstrate what happens when deployments request more than the quota.  First we will delete the deployment, and then the PVC. Then view the PVC.</p><pre><code class="language-bash">kubectl -n small get deploy
kubectl -n small delete deploy nginx-nfs
kubectl describe ns small
kubectl -n small get pvc
kubectl -n small delete pvc pvc-one
kubectl describe ns small
kubectl -n small get pv
kubectl -n small get pv/pvvol-1 -o yaml
</code></pre><p>Notice that the quota didn&#x27;t change until the PVC was deleted.  Also take note of the <code>persistentVolumeReclaimPolicy</code> of the StorageClass.  This value could be <code>Delete</code>, <code>Retain</code>, or <code>Recycle</code>, but manually created PVs default to <code>Retain</code> unless set otherwise when creating.  This is the default because it allows for recovery of any data since the storage is kept.  Let&#x27;s change this from the default.</p><p>Currently we need to delete the PV and then recreate it, but future development plans on having a deleter plugin. We will then recreate the PV and then use <code>kubectl patch</code> command to update the policy to <code>Delete</code>.</p><pre><code class="language-bash">kubectl delete pv/pvvol-1
grep Retain PVol.yaml
kubectl create -f PVol.yaml
kubectl patch pv pvvol-1 -p &#x27;{&quot;spec&quot;:{&quot;persistentVolumeReclaimPolicy&quot;:&quot;Delete&quot;}}&#x27;
kubectl get pv/pvvol-1
</code></pre><p>Now check the quota on the namespace and then recreate the PVC and check again. You should see the usage go up, even without Pods deployed.</p><pre><code class="language-bash">kubectl describe ns small
kubectl create -n small -f pvc.yaml
kubectl describe ns small
</code></pre><p>Now we will delete the quota and reduce the capacity to 100Mi.</p><pre><code class="language-bash">kubectl -n small get resourcequota
kubectl -n small delete resourcequota storagequota
vim storage-quota.yaml
kubectl -n small create -f storage-quota.yaml
kubectl describe ns small
</code></pre><p>Note when we describe the namespace to view the limits that the hard limit has already been exceeded. Now we will recreate the Deployment and check the Pods are running. Note that no errors will show.</p><pre><code class="language-bash">kubectl -n small create -f nfs-pod.yaml
kubectl -n small describe deploy/nginx-nfs
kubectl -n small get po
</code></pre><p>Since we are able to deploy Pods with no error even with the quota exceeded, we will delete the deployment and PVC to see if the Reclaim event takes place.</p><pre><code class="language-bash">kubectl -n small delete deploy nginx-nfs
kubectl -n small delete pvc/pvc-one
kubectl -n small get pv
</code></pre><p>Notice the <code>STATUS</code> is <code>Failed</code>.  This has to do with the lack of a deleter volume plugin for NFS. Other storage protocols have a plugin for this.</p><p>Go ahead and delete the PV and then edit the PV manifest and change the <code>persistentVolumeReclaimPolicy</code> to <code>Recycle</code>.</p><pre><code class="language-bash">kubectl delete pv/pvvol-1
vim PVol.yaml
</code></pre><p>Now we&#x27;ll add a LimitRange to the new namespace and try to create the PV and PVC again. We can reuse the LimitRange from a previous lab.</p><pre><code class="language-bash">kubectl -n small create -f low-resource-range.yaml
kubectl describe ns small
</code></pre><p>You should see both quota and resource limits applied to the namespace. Now recreate the PV and PVC. Note the PV has a <code>Recycle</code> reclaim policy.</p><pre><code class="language-bash">kubectl -n small create -f PVol.yaml
kubectl get pv
kubectl -n small create -f pvc.yaml
</code></pre><p>You should get an error when creating the PVC.  The quota only takes effect when there is a resource limit in effect.</p><p>Change the <code>resourcequota</code> to increase requested storage to 500Mi under <code>spec.hard.requests.storage</code> and then recreate the PVC and Deployment.</p><pre><code class="language-bash">kubectl -n small edit resourcequota
kubectl -n small create -f pvc.yaml
kubectl -n small create -f nfs-pod.yaml
kubectl describe ns small
</code></pre><p>Delete the deployment and then view the PV and PVC.</p><pre><code class="language-bash">kubectl -n small delete deployment nginx-nfs
kubectl -n small get pvc,pv
</code></pre><p>Then delete the PVC and view the PV. You should see it is <code>Available</code>.</p><pre><code class="language-bash">kubectl -n small delete pvc pvc-one
kubectl -n small get pv
</code></pre><p>Then finally you can delete the PV.</p><pre><code class="language-bash">kubectl delete pv pvvol-1
</code></pre><h2 id="knowledge-check">Knowledge check</h2><ul><li>Applications are <strong>not</strong> required to use persistent storage.</li><li>A Deployment uses a <strong>PersistentVolumeClaim</strong>.</li><li>The <code>persistentVolumeReclaimPolicy</code> determines what happens to the persistent storage upon release.</li><li>Secrets does <strong>not</strong> contain encrypted data.</li><li>ConfigMaps can be created from <strong>literal values</strong>, <strong>individual files</strong>, or <strong>many files in a directory</strong>.</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fundamentals/chapter08.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cka-prep/docs/fundamentals/chapter07"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Managing State with Deployments</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/cka-prep/docs/fundamentals/chapter09"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Services</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#course-reading" class="table-of-contents__link toc-highlight">Course Reading</a><ul><li><a href="#learning-objectives" class="table-of-contents__link toc-highlight">Learning objectives</a></li><li><a href="#overview" class="table-of-contents__link toc-highlight">Overview</a></li><li><a href="#introducing-volumes" class="table-of-contents__link toc-highlight">Introducing volumes</a></li><li><a href="#volume-spec" class="table-of-contents__link toc-highlight">Volume spec</a></li><li><a href="#volume-types" class="table-of-contents__link toc-highlight">Volume types</a></li><li><a href="#shared-volume-example" class="table-of-contents__link toc-highlight">Shared volume example</a></li><li><a href="#persistent-volumes-and-claims" class="table-of-contents__link toc-highlight">Persistent volumes and claims</a></li><li><a href="#persistent-volume" class="table-of-contents__link toc-highlight">Persistent Volume</a></li><li><a href="#persistent-volume-claim" class="table-of-contents__link toc-highlight">Persistent Volume Claim</a></li><li><a href="#dynamic-provisioning" class="table-of-contents__link toc-highlight">Dynamic provisioning</a></li><li><a href="#using-rook-for-storage-orchestration" class="table-of-contents__link toc-highlight">Using Rook for storage orchestration</a></li><li><a href="#secrets" class="table-of-contents__link toc-highlight">Secrets</a></li><li><a href="#using-secrets-via-environment-variables" class="table-of-contents__link toc-highlight">Using secrets via environment variables</a></li><li><a href="#mounting-secrets-as-volumes" class="table-of-contents__link toc-highlight">Mounting secrets as volumes</a></li><li><a href="#portable-data-with-configmaps" class="table-of-contents__link toc-highlight">Portable data with ConfigMaps</a></li><li><a href="#using-configmaps" class="table-of-contents__link toc-highlight">Using ConfigMaps</a></li></ul></li><li><a href="#lab-exercises" class="table-of-contents__link toc-highlight">Lab Exercises</a><ul><li><a href="#lab-81---create-a-configmap" class="table-of-contents__link toc-highlight">Lab 8.1 - Create a ConfigMap</a></li><li><a href="#lab-82---create-a-persistent-nfs-volume-pv" class="table-of-contents__link toc-highlight">Lab 8.2 - Create a persistent NFS volume (PV)</a></li><li><a href="#lab-83---creating-a-persistent-volume-claim-pvc" class="table-of-contents__link toc-highlight">Lab 8.3 - Creating a persistent volume claim (PVC)</a></li><li><a href="#lab-84---use-a-resourcequota-to-limit-pvc-count-and-usage" class="table-of-contents__link toc-highlight">Lab 8.4 - Use a ResourceQuota to limit PVC count and usage</a></li></ul></li><li><a href="#knowledge-check" class="table-of-contents__link toc-highlight">Knowledge check</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/cka-prep/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/andrewdaoust/cka-prep" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 Andrew D'Aoust. Built with Docusaurus.</div></div></div></footer></div>
<script src="/cka-prep/assets/js/runtime~main.96d354ef.js"></script>
<script src="/cka-prep/assets/js/main.d9dff869.js"></script>
</body>
</html>