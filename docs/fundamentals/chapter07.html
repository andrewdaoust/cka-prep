<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">Managing State with Deployments | CKA Prep</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/cka-prep/docs/fundamentals/chapter07"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Managing State with Deployments | CKA Prep"><meta data-react-helmet="true" name="description" content="Course Reading"><meta data-react-helmet="true" property="og:description" content="Course Reading"><link data-react-helmet="true" rel="icon" href="/cka-prep/img/k8s.png"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/cka-prep/docs/fundamentals/chapter07"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/cka-prep/docs/fundamentals/chapter07" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/cka-prep/docs/fundamentals/chapter07" hreflang="x-default"><link rel="stylesheet" href="/cka-prep/assets/css/styles.e68b4784.css">
<link rel="preload" href="/cka-prep/assets/js/runtime~main.12fc88c9.js" as="script">
<link rel="preload" href="/cka-prep/assets/js/main.d9dff869.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/cka-prep/"><div class="navbar__logo"><img src="/cka-prep/img/kubernetes-icon.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/cka-prep/img/kubernetes-icon.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">CKA Prep</b></a><a class="navbar__item navbar__link navbar__link--active" href="/cka-prep/docs/intro">Notes</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/andrewdaoust/cka-prep" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cka-prep/docs/intro">Kubernetes Resources</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/cka-prep/docs/fundamentals">Kubernetes Fundamentals</a><button aria-label="Toggle the collapsible sidebar category &#x27;Kubernetes Fundamentals&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter01">Course Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter02">Basics of Kubernetes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter03">Installation and Configuration</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter04">Kubernetes Architecture</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter05">APIs and Access</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter06">API Objects</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/cka-prep/docs/fundamentals/chapter07">Managing State with Deployments</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter08">Volumes and Data</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter09">Services</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter10">Helm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter11">Ingress</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter12">Scheduling</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter13">Logging and Troubleshooting</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter14">Custom Resource Definitions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter15">Security</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter16">High Availability</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/chapter17">Exam Domain Review</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cka-prep/docs/fundamentals/follow-up">Follow-up Items</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/cka-prep/docs/kubectl/setup">kubectl</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/cka-prep/docs/hard-way/about">Kubernetes the Hard Way</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/cka-prep/docs/linux">Linux</a><button aria-label="Toggle the collapsible sidebar category &#x27;Linux&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/cka-prep/docs/misc">Miscellaneous Topics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Miscellaneous Topics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Managing State with Deployments</h1></header><h2 id="course-reading">Course Reading</h2><h3 id="learning-objectives">Learning objectives</h3><ul><li>Discuss Deployment configuration details</li><li>Scale Deployments up and down</li><li>Implement rolling updates and rollback</li><li>Use Labels to select various objects</li></ul><h3 id="overview">Overview</h3><p>When you run <code>kubectl run</code>, the default controller is a Deployment. This chapter focuses more in detail in the configuration of them.  Deployments, like other objects, can be defined in YAML or JSON, and when added to the cluster, a ReplicaSet and Pod will be created automatically.  </p><p>Deployment settings can be changed via an update which will create a new ReplicaSet which will then create new Pods. Updates can be applied as a block change or via a rolling update. Most updates can be configured by editing the YAML file defining the object and then running a <code>kubectl apply</code>. A <code>kubectl edit</code> can also be used to modify the in-use config.  Previous ReplicaSet versions are kept in case a rollback is needed.</p><p>This section also focuses on labels. These are essential for Kubernetes administration, but they are not an API resource.  Labels are user defined key-value pairs attached to resources stored in the object metadata.  Tey can be used to query or select resources in the cluster, which allows for flexible and complex management. Since labels are arbitrary, you can select all resources that share a label value without having to figure out what kind or how many of these resources exist.</p><h3 id="deployments">Deployments</h3><p>Deployments came about as enhanced versions of ReplicaControllers (RC). ReplicaControllers ensure a specified number of Pod replicas are running at any one time.  They also give the ability to perform rolling updates, however all updates are managed on the client side, which is problematic if the client loses connection which can leave the cluster in an unplanned state.</p><p>To avoid these issues Deployments were introduced in the <code>apps/v1</code> API group.  They allow for server-side updates to Pods at specified rates.  Deployments can be used for canary and other deployment patterns. A Deployment generates a ReplicaSet, which offer more selection features than ReplicaControllers. One example is <code>matchExpressions</code>.</p><p>You can create a Deployment from an existing image with <code>kubectl</code> like so</p><pre><code class="language-bash">kubectl create deployment dev-web --image=nginx
</code></pre><h3 id="object-relationship">Object relationship</h3><p><img alt="object relationship" src="/cka-prep/assets/images/ch07-obj-relationship-79ce6aac35c486207615483ff9248c5b.png" width="656" height="306"></p><p>The diagram shows relationships between Kubernetes object.  Each of the boxes represent the controllers running as a thread of the kube-controller-manager, where each controller queries the kube-apiserver for the current state of the tracked object.</p><p>Walking through the diagram, we first see a Nginx container running version 1.11.  Kubernetes does not directly manage the container. Instead, the kubelet daemon checks the Pod spec by checking the runtime engine for the current status.  Next to the container we see a Pod, which is a representation of a watch loop checking the container status. The kubelet continues to compare the container spec to the response from the runtime engine, and will terminate the Pod if needed. Next to the Pod is an example of a multi-container Pod.  This works on the same principle as a single container Pod, except the watch loop needs to monitor both containers in this case.</p><p>Next is the ReplicaSet, which is a controller that ensured a certain number of replicas of a Pod are running. Each Pod is deployed with the same specification. If a Pod is terminated or a new one is found, the ReplicaSet will create or terminate Pods until the number of running Pods matching the specified replica count.  Since all the replicas are the same, any could be terminated should the spec demand a change in the number of running Pods.</p><p>Finally we have the deployment, which is a controller that manages the ReplicaSets.  They allow us to manage the version of images running in the Pods they oversee.  If a Deployment is changes, a new ReplicaSet is created, which in turn deploys new Pods using the updated podSpec. Once new Pods are running the Deployment instructs the old ReplicaSet to start terminating its Pods and eventually itself once the Pods are all shut down, and only the new ReplicaSet, with its Pods, is running.</p><h3 id="deployment-details">Deployment details</h3><p>If you ran the command to create the <code>nginx</code> deployment in the <a href="#deployments">Deployments</a> section above you could then list the YAML or JSON output for the resources it just created like so:</p><pre><code class="language-bash">kubectl get deployments,rs,pods -o yaml
kubectl get deployments,rs,pods -o json
</code></pre><p>The first few lines of the YAML response should look like this.</p><pre><code class="language-yaml">apiVersion: v1
items:
- apiVersion: apps/v1
  kind: Deployment
</code></pre><p>Let&#x27;s discuss each of these lines.</p><p>First is the <code>apiVersion</code>.  This denotes the stability of the object we ar looking at.  <code>v1</code> denotes the object as stable, and it referring to the <code>List</code> type that the <code>items</code> parameter defines.</p><p>Within the <code>items</code> we see the first object has an <code>apiVersion</code> of <code>apps/v1</code>, which means it is also stable.  We also see the <code>kind</code> field, showing us we are looking at the specification for a <code>Deployment</code>.</p><h3 id="deployment-configuration-metadata">Deployment configuration metadata</h3><p>Continuing from the YAML output we got from the <a href="#deployment-details">previous section</a>, we next see the <code>metadata</code> field for the deployment which looks something like this.</p><pre><code class="language-yaml">  metadata:
    annotations:
      deployment.kubernetes.io/revision: &quot;1&quot;
    creationTimestamp: &quot;2022-05-10T18:21:45Z&quot;
    generation: 1
    labels:
      app: dev-web
    name: dev-web
    namespace: default
    resourceVersion: &quot;278969&quot;
    uid: 519529f2-6e77-4413-8df5-c498bd127e71
</code></pre><p>This is the section that would contain any labels, annotations, or other non-configuration information.  Here&#x27;s what each of the sub-parameters in the <code>metadata</code> is used for:</p><h4 id="annotations"><code>annotations</code></h4><p>These values do not configure the object, but are helpful to provide further information for tracking or for third-party applications.  Unlike labels, annotations cannot be used for selection with <code>kubectl</code>.</p><h4 id="creationtimestamp"><code>creationTimestamp</code></h4><p>This is the original creation time of the object. It does <strong>not</strong> update when the object is updated.</p><h4 id="generation"><code>generation</code></h4><p>Is a count of how many times the object has been edited. Changing things such as the number of replicas would modify this field.</p><h4 id="labels"><code>labels</code></h4><p>Labels are similar to annotations except they can be used for selection with <code>kubectl</code> or other API calls.  This is helpful for cluster administration to select groups of different objects that may be related or for excluding other objects from queries.</p><h4 id="name"><code>name</code></h4><p>This metadata field is a required string value. When we created the object we passed it, <code>dev-web</code>.  The name must be unique to the namespace the object is a part of.</p><h4 id="resourceversion"><code>resourceVersion</code></h4><p>This is a value tied to the etcd database to help with object concurrency.  Changes to the database cause this number to change.</p><h4 id="uid"><code>uid</code></h4><p>A unique ID for the life of the object.</p><p>Also, it should be noted that the output will not include every configuration setting, as many are set to false by default and therefore are not shown, such as <code>podAffinity</code> and <code>nodeAffinity</code>.</p><h3 id="deployment-configuration-spec">Deployment configuration spec</h3><p>Continuing on down the output, we next see the <code>spec</code> section. There a two <code>spec</code> declarations for a deployment, the first is for ReplicaSet, and the second for the Pod.  The first one looks like this in the output from previously.</p><pre><code class="language-yaml">  spec:
    progressDeadlineSeconds: 600
    replicas: 1
    revisionHistoryLimit: 10
    selector:
      matchLabels:
        app: dev-web
    strategy:
      rollingUpdate:
        maxSurge: 25%
        maxUnavailable: 25%
      type: RollingUpdate
</code></pre><h4 id="progressdeadlineseconds"><code>progressDeadlineSeconds</code></h4><p>This is the time until a progress error is reported when a change occurs.  These errors could happen for a variety of reasons, such as quotas, image issues, or limit ranges.</p><h4 id="replicas"><code>replicas</code></h4><p>Since this <code>spec</code> defines a ReplicaSet, this parameter is needed to determine how many replicas of a Pod the ReplicaSet needs to ensure. If you changes the replicas to 2 with a <code>kubectl edit</code>, a second Pod would be spun up.</p><h4 id="revisionhistorylimit"><code>revisionHistoryLimit</code></h4><p>This is the number of old ReplicaSet specifications that are retained in case a rollback is needed.</p><h4 id="selector"><code>selector</code></h4><p>The <code>selector</code> field is a collection of values ANDed together. All must be satisfied for the replica to match.  Do not create a Pod that matches these selectors as the Deployment controller could potentially try to control these resource, leading to issues.</p><p>The <code>matchLabels</code> sub-parameter define set-based requirements for the Pod selector.  This is often paired with the <code>matchExpressions</code> statement as well to further define where resources should be scheduled.</p><h4 id="strategy"><code>strategy</code></h4><p>The strategy section defines values regarding updates for Pods. It works with the later defined <code>type</code> field which specifies the strategy for updating Pods. In the case of the example, it is a <code>RollingUpdate</code>, which has other parameters that can be defined to control the number of Pods deleted at a time.  Even through it is defined last here, it is what is read to determine the object being configured.</p><p>For a <code>RollingRestart</code> we can define <code>maxSurge</code> and <code>maxUnavailable</code> fields.  The <code>maxSurge</code> parameter defines the number of Pods that can be created above the desired limit.  It can be a percentage, like the default 25% here, or an absolute number.  This creates a certain number of new Pods before deleting any old ones for continued access to the running application.  The <code>maxUnavailable</code> field is the configured number or percentage of Pods that can be in a state other than <code>Ready</code> during the update process.</p><p>The <code>strategy</code> could also be set to <code>Recreate</code> which would delete all existing Pods before creating any new ones.</p><h3 id="deployment-configuration-pod-template">Deployment configuration Pod template</h3><p>Next is the <code>template</code> section, which is actually contained within the <code>spec</code> section we discussed about <a href="#deployment-configuration-spec">above</a>. it looks something like this:</p><pre><code class="language-yaml">    template:
      metadata:
        creationTimestamp: null
        labels:
          app: dev-web
      spec:
        containers:
        - image: nginx:1.13.7-alpine
          imagePullPolicy: IfNotPresent
          name: nginx
          resources: {}
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
        securityContext: {}
        terminationGracePeriodSeconds: 30
</code></pre><p>This is the template used for each of the Pods to be deployed. Again, let&#x27;s break down each section.</p><h4 id="template"><code>template</code></h4><p>The template header defines the configuration that is passed to the ReplicaSet for how to deploy an object (in this case Pods/containers).</p><p>We again see a <code>metadata</code> section which serves the same function <a href="#deployment-configuration-metadata">as discussed here</a>.</p><h4 id="containers"><code>containers</code></h4><p>This keyword indicates the following items of the array are specification for the containers that will be deployed in the Pod. Each container has some more keywords to configure.</p><p>The first is <strong><code>image</code></strong>, which is the name of the image passed to the container runtime engine.  The engine pulls the image and creates the Pod.</p><p>We also define an <strong><code>imagePullPolicy</code></strong> to define when and if an image should be downloaded or if the locally cached image should be used. This can take three values. <code>IfNotPresent</code> pulls the image only if it is not present locally.  <code>Always</code> will make the kubelet alway query the container registry to pull the image before launching a new one. <code>Never</code> will make the kubelet never pull the image, which causes startup to fail if the image is not present locally already.</p><p>The <strong><code>name</code></strong> field denoted the stub of the Pod name, with a unique string being appended to the end.</p><p><strong><code>resources</code></strong> by default are empty.  This is where any resource restrictions or limits, like for CPU or memory, would be configured for the containers.</p><p>The <strong><code>terminationMessagePath</code></strong> defines the location where to output success or failure information from a container. The <strong><code>terminationMessagePolicy</code></strong> holds the termination method.  The default is <code>File</code>, but it can also be set to <code>FallbackToLogsOnError</code> which uses the last chunk of container logs if the message file is empty and the container is showing an error.</p><h4 id="dnspolicy"><code>dnsPolicy</code></h4><p>This determines is the DNS queries should go through <strong>coredns</strong>.  If set to <code>Default</code>, the node&#x27;s DNS resolution configuration is used.</p><h4 id="restartpolicy"><code>restartPolicy</code></h4><p>This defines is containers should be restarted if killed.  Automatic restarts are part of the usual strength of Kubernetes.</p><h4 id="schedulername"><code>schedulerName</code></h4><p>This allows for the use of a custom scheduler if you don&#x27;t want to use the Kubernetes default.</p><h4 id="securitycontext"><code>securityContext</code></h4><p>A flexible setting to pass one or many security settings. These could include SELinux context, AppArmor values, users, and UIDs for the containers to use.</p><h4 id="terminationgraceperiodseconds"><code>terminationGracePeriodSeconds</code></h4><p>Sets the amount of time to wait for a <code>SIGTERM</code> to run before a <code>SIGKILL</code> is used to terminate the container.</p><h3 id="deployment-configuration-status">Deployment configuration status</h3><p>Now, let&#x27;s take a look at the <code>status</code> section of the output for our Deployment object.</p><pre><code class="language-yaml">  status:
    availableReplicas: 1
    conditions:
    - lastTransitionTime: &quot;2022-05-10T18:21:47Z&quot;
      lastUpdateTime: &quot;2022-05-10T18:21:47Z&quot;
      message: Deployment has minimum availability.
      reason: MinimumReplicasAvailable
      status: &quot;True&quot;
      type: Available
    - lastTransitionTime: &quot;2022-05-10T18:21:45Z&quot;
      lastUpdateTime: &quot;2022-05-10T18:21:47Z&quot;
      message: ReplicaSet &quot;dev-web-565cb67bd6&quot; has successfully progressed.
      reason: NewReplicaSetAvailable
      status: &quot;True&quot;
      type: Progressing
    observedGeneration: 1
    readyReplicas: 1
    replicas: 1
    updatedReplicas: 1
</code></pre><p>Some sections to note in the <code>status</code> are the <code>availableReplicas</code> and <code>observedGeneration</code> fields.  The <code>availableReplicas</code> indicates how many replicas were configured by the ReplicaSet.  This is then later compared to <code>readyReplicas</code> to determine if all have been fully created without error.</p><p>The <code>observedGeneration</code> parameter shows how often the deployment has been updated, which can be used to understand the rollout and rollback situation of the deployment.</p><h3 id="scaling-and-rolling-updates">Scaling and rolling updates</h3><p>The kube-apiserver allows most configuration settings to be updated, however there are some that are immutable which can differ depending on the version of Kubernetes deployed.</p><p>A more common update is scaling the number of replicas for a Deployment.  You could in theory also scale a Deployment to 0 replicas, leaving just a ReplicaSet and a Deployment, which behind the scenes is what happens when a Deployment is deleted. As an example, let&#x27;s scale the Nginx deployment we created earlier.</p><pre><code class="language-bash">kubectl scale deploy/dev-web --replicas=4
</code></pre><p>For immutable values, we can edit the deployment and trigger an update.  Again, using the example of our Nginx deployment we could do</p><pre><code class="language-bash">kubectl edit deployment dev-web
</code></pre><p>This would open up a text editor and you could make a change, like for example the image version.</p><pre><code class="language-yaml">...
      containers:
      - image: nginx:1.8   # &lt;-- Update this to an older version
        imagePullPolicy: IfNotPresent
        name: nginx
...
</code></pre><p>The <code>edit</code> command then triggers the update of the Deployment. While the Deployment shows its age as the original creation time, inspecting the Pods would show that they had been recently created.</p><h3 id="deployment-rollbacks">Deployment rollbacks</h3><p>Some previous ReplicaSets and Deployments are kept in the case a rollback is needed.  The number kept is configurable and changes version to version.  Let&#x27;s take a loot at how rollbacks can be made.</p><pre><code class="language-bash">kubectl create deploy ghost --image=ghost
kubectl get deploy ghost -o yaml
</code></pre><p>This is what the deployment should look like:</p><pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: &quot;1&quot;
  creationTimestamp: &quot;2022-05-11T16:17:57Z&quot;
  generation: 1
  labels:
    app: ghost
  name: ghost
  namespace: default
  resourceVersion: &quot;296422&quot;
  uid: 985f8c5a-8040-4c00-81b9-833dd03bde0a
spec:
  progressDeadlineSeconds: 600
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: ghost
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: ghost
    spec:
      containers:
      - image: ghost
        imagePullPolicy: Always
        name: ghost
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
status:
  availableReplicas: 1
  conditions:
  - lastTransitionTime: &quot;2022-05-11T16:18:15Z&quot;
    lastUpdateTime: &quot;2022-05-11T16:18:15Z&quot;
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: &quot;True&quot;
    type: Available
  - lastTransitionTime: &quot;2022-05-11T16:17:57Z&quot;
    lastUpdateTime: &quot;2022-05-11T16:18:15Z&quot;
    message: ReplicaSet &quot;ghost-5c7f765cdc&quot; has successfully progressed.
    reason: NewReplicaSetAvailable
    status: &quot;True&quot;
    type: Progressing
  observedGeneration: 1
  readyReplicas: 1
  replicas: 1
  updatedReplicas: 1
</code></pre><p>If an update were to fail, you can roll back to a previous version with a <code>kubectl rollout undo</code></p><pre><code class="language-bash">kubectl set image deployment/ghost ghost=ghost:09 --all
kubectl rollout history deployment/ghost
kubectl get pods
</code></pre><p>When getting the Pods, you should see the new <code>ghost</code> Pod is erroring, likely with a <code>ErrImagePull</code> or <code>ImagePullBackOff</code> status since the tag we specified on the image was bad.</p><p>To fix this we can undo the change.</p><pre><code class="language-bash">kubectl rollout undo deployment/ghost
kubectl get pods
</code></pre><p>You should then see the <code>ghost</code> Pod working normally again.  You can also specify a specific revision to roll back to using the <code>--to-revision=</code> flag and specifying the revision number from the <code>rollout history</code> command.</p><p>Deployments can be paused and resumes as well with</p><pre><code class="language-bash">kubectl rollout pause deployment/ghost
kubectl rollout resume deployment/ghost
</code></pre><p>ReplicationControllers can have rolling updates applied with <code>kubectl rolling-update</code> command, but as mentioned before, this is done on the client side. So if a connection is lost the update will stop.</p><h3 id="using-daemonsets">Using DaemonSets</h3><p>A newer object is a <code>DaemonSet</code>, which ensures a single Pod is running on each cluster node.  Every Pod the DaemonSet manages uses the same image, and when new nodes are added, the controller will deploy a new, identical Pod on it. If the node is removed, the controller will also delete the Pod first.</p><p>DaemonSets are useful in that it ensured a particular container is always running on every node, which in a large dynamic environment is helpful so an administrator does not always need to remember to deploy certain things, like for example a logging or metric generation application.</p><p>There are ways to effect the kube-apiserver so that DaemonSets do not run on certain nodes.</p><h3 id="labels-1">Labels</h3><p>Labels are an important tool for cluster administration.  They can be used for selection using an arbitrary string regardless of the object type.  Labels are immutable as of <code>apps/v1</code>.</p><p>Any resource can contain labels in its metadata. By default, when you use <code>kubectl create</code> to launch a Deployment, some labels are added.</p><pre><code class="language-yaml">...
  labels:
    app: ghost
    pod-template-hash: 5c7f765cdc
...
</code></pre><p>Here are some examples of using and adding labels.</p><p>For example, you could get Pod with the label <code>app</code> and a value of <code>ghost</code>.</p><pre><code class="language-bash">kubectl get pods -l app=ghost
</code></pre><p>Or you could get all the Pods with the <code>app</code> label and list their values as another column like so.</p><pre><code class="language-bash">kubectl get pods -L app
</code></pre><p>Labels are usually defined in Pod templates in Deployment spec but you can also add them on the fly.</p><pre><code class="language-bash">kubectl label pods ghost-&lt;uid&gt; foo=bar
</code></pre><p>And you can show the labels on each pod with a <code>get</code></p><pre><code class="language-bash">kubectl get pods --show-labels
</code></pre><h2 id="lab-exercises">Lab Exercises</h2><h3 id="lab-71---working-with-replicasets">Lab 7.1 - Working with ReplicaSets</h3><p>This lab explored the objects that help to manage containers, a core task of Kubernetes. As Kubernetes has matured, the objects used to do this have changed. We will look at <code>ReplicaSets</code> which don&#x27;t have more of the newer features Deployments have for management. We will also look at <code>Deployments</code> which manage ReplicaSets for us, as well as <code>DaemonSets</code> for when we want to ensure a container is run on every node of the cluster.</p><p>The ReplicaSet was an evolution on Replica Controllers, which differ only on the selectors available for use. The only reason to use a ReplicaSet instead of a Deployment is if you will not need to update software or orchestrate updates.</p><p>First, check to see that there are no resources currently on the cluster.</p><pre><code class="language-bash">kubectl get rs
</code></pre><p>You should find that <code>No resources found in default namespace.</code></p><p>Next, create a YAML file to define a simple ReplicaSet.</p><pre><code class="language-bash">vim rs.yaml
</code></pre><p>And in the YAML enter the following specification</p><pre><code class="language-yaml">apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: rs-one
spec:
  replicas: 2
  selector:
    matchLabels:
      system: ReplicaOne
  template:
    metadata:
      labels:
        system: ReplicaOne
    spec:
      containers:
      - name: nginx
        image: nginx:1.15.1
        ports:
        - containerPort: 80
</code></pre><p>And then create the ReplicaSet.</p><pre><code class="language-bash">kubectl create -f rs.yaml
</code></pre><p>Then view the newly created ReplicaSet and the Pods it created. You should see two Pods running.</p><pre><code class="language-bash">kubectl describe rs rs-one
kubectl get pods
</code></pre><p>Now let&#x27;s delete the ReplicaSet, but not the Pods it controls.</p><pre><code class="language-bash">kubectl delete rs rs-one --cascade=orphan
</code></pre><p>Then, try to describe the ReplicaSet and view the Pods again.</p><pre><code class="language-bash">kubectl describe rs rs-one
kubectl get pods
</code></pre><p>When you <code>describe</code> the ReplicaSet you should see an error like <code>Error from server (NotFound): replicasets.apps &quot;rs-one&quot; not found</code> but when you list the Pods you should still see the two running that you had before.</p><p>We can then recreate the ReplicaSet, and as long as the selector field is the same, it should take ownership of the running Pods. Pod software versions cannot be updated with this method.</p><pre><code class="language-bash">kubectl create -f rs.yaml
</code></pre><p>Now view the <code>AGE</code> of both the ReplicaSet and the Pods it manages.</p><pre><code class="language-bash">kubectl get rs
kubectl get pods
</code></pre><p>You should see the ReplicaSet is newer than the Pods, as the Pods have been unchanged since they were created by the original ReplicaSet.</p><p>Next we will isolate one of the Pods from the ReplicaSet, which we will do by editing the label of the Pod. We will update the <code>system</code> parameter to be <code>IsolatedPod</code>.</p><pre><code class="language-bash">kubectl edit pod rs-one-&lt;unique ID&gt;
</code></pre><p>Now if you check the ReplicaSet, you should see two Pods are still running.</p><pre><code class="language-bash">kubectl get rs
</code></pre><p>Now if you get the Pods as well, you should see there are now three running. And if you view them again using while showing the <code>system</code> label, you will see one has the <code>IsolatedPod</code> value we had set earlier. The ReplicaSet has done its job to make sure that the configured number of Pods are running under it&#x27;d defined criteria (in this case with the <code>system</code> label of <code>ReplicaOne</code>).</p><pre><code class="language-bash">kubectl get pods
kubectl get po -L system
</code></pre><p>Now if you delete the ReplicaSet and get the Pods and ReplicaSets</p><pre><code class="language-bash">kubectl delete rs rs-one
kubectl get pods,rs
</code></pre><p>you should only see the orphaned Pod with the changed <code>system</code> label.</p><p>Finally, delete the orphaned Pod.</p><pre><code class="language-bash">kubectl delete pod -l system=IsolatedPod
</code></pre><h3 id="lab-72---working-with-daemonsets">Lab 7.2 - Working with DaemonSets</h3><p><code>DaemonSets</code> are watch loops just like Deployments, but they serve the purpose to ensure that when nodes are added to the cluster a Pod is run on them. Deployments on the other hand only ensure that a certain number of Pods are created in general, not where they are allocated. DaemonSets are helpful since they ensure an application is on each node which can be helpful for things like logging and metrics, especially on large clusters where nodes are swapped often.  DaemonSets are also very helpful because they manage the garbage collection of Pods when nodes are terminated from the cluster.  Starting in <code>v1.12</code>, the scheduler handles the deployment of DaemonSets which allows for exclusion of certain nodes from the DaemonSet&#x27;s scope.</p><p>First, we will copy the YAML file we created for the ReplicaSet and use it as the base for the DaemonSet.</p><pre><code class="language-bash">cp rs.yaml ds.yaml
vim ds.yaml
</code></pre><p>In the <code>vim</code> editor window update the <code>kind</code> to <code>DaemonSet</code>, the <code>name</code> to <code>ds-one</code>, the <code>system</code> label to <code>DaemonSetOne</code>, and remove the <code>replicas</code> definition.</p><p>Then, create and verify the new DaemonSet.</p><pre><code class="language-bash">kubectl create -f ds.yaml
kubectl get ds,pods
</code></pre><p>Then verify the image running inside each Pod.</p><pre><code class="language-bash">kubectl describe pod ds-one-&lt;unique ID&gt; | grep Image:
</code></pre><p>You should see both are running an Nginx v1.15.1 container.</p><h3 id="lab-73---rolling-updates-and-rollbacks">Lab 7.3 - Rolling Updates and Rollbacks</h3><p>One advantage of micro-services is that an update can be applied to a container without disrupting the response to client requests.</p><p>In this section we will use the <code>OnDelete</code> and <code>RollingUpdate</code> strategies to update our DaemonSet.  The <code>OnDelete</code> will upgrade a container once the one it is replacing is deleted. A <code>RollingUpdate</code> will bring up a new container immediately to replace the out-of-date Pod.</p><p>First let&#x27;s check the update strategy of the DaemonSet we specified in <a href="#lab-72---working-with-daemonsets">lab 7.2</a>.</p><pre><code class="language-bash">kubectl get ds ds-one -o yaml | grep -A 4 Strategy
</code></pre><p>You should see that it is currently using a <code>RollingUpdate</code>. Let&#x27;s edit the DaemonSet to use an <code>OnDelete</code> strategy by changing the <code>type</code> field in under the <code>updateStrategy</code>.</p><pre><code class="language-bash">kubectl edit ds ds-one
</code></pre><p>Now let&#x27;s update the Nginx image the Pods are using. And then we will verify that the image has not yet changed.</p><pre><code class="language-bash">kubectl set image ds ds-one nginx=nginx:1.16.1-alpine
kubectl describe po ds-one-&lt;unique ID&gt; | grep Image:
</code></pre><p>Now delete one of the Pods. Verify the new Pod is up an running and check the image again.</p><pre><code class="language-bash">kubectl delete pod ds-one-&lt;unique ID&gt;
kubectl get pod
kubectl describe pod ds-one-&lt;new unique ID&gt; | grep Image:
</code></pre><p>Check the other Pod and you should see it is still running the <code>1.15.1</code> image.</p><p>Now let&#x27;s create a new DaemonSet using the original as a base, updating the name to <code>ds-two</code> and changing the strategy back to the default <code>RollingUpdate</code>.</p><pre><code class="language-bash">kubectl get ds ds-one -o yaml &gt; ds2.yaml
vim ds2.yaml
kubectl create -f ds2.yaml
</code></pre><p>Verify the image. It should be using the new <code>1.16.1-alpine</code> image that we updated to earlier.</p><pre><code class="language-bash">kubectl get pods
kubectl describe pod ds-two-&lt;unique ID&gt; | grep Image:
</code></pre><p>Now let&#x27;s change the image back to <code>1.15.1</code> with the <code>edit</code> command and then check the DaemonSet and Pods.</p><pre><code class="language-bash">kubectl edit ds ds-two
kubectl get ds ds-two
kubectl get pods
kubectl describe pod ds-two-&lt;unique ID&gt; | grep Image:
</code></pre><p>Notice the Pods for <code>ds-two</code> are much newer than the DaemonSet itself and that the Nginx image is <code>1.15.1</code>. This is because the edit took effect right away because we changed the strategy to <code>RollingUpdate</code>.</p><p>Then view the rollout status and history and then clean up the resources.</p><pre><code class="language-bash">kubectl rollout status ds ds-two
kubectl rollout history ds ds-two
kubectl rollout history ds ds-two --revision=2
kubectl delete ds ds-one ds-two
</code></pre><h2 id="knowledge-check">Knowledge check</h2><ul><li>The <strong><code>replicas</code></strong> field determines the number of duplicate Pods deployed by a Deployment</li><li>The <strong><code>strategy</code></strong> field is a header that has to do with updating Pods.</li><li><strong>Labels</strong> are metadata used to select an object with <code>kubectl</code>, based on an arbitrary string, regardless of the object type</li><li>The <strong><code>history</code></strong> argument is passed to <code>kubectl rollout</code> to see the revision history of an object</li><li>The <strong><code>undo</code></strong> argument is passed to <code>kubectl rollout</code> to return to a previous object version</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fundamentals/chapter07.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/cka-prep/docs/fundamentals/chapter06"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">API Objects</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/cka-prep/docs/fundamentals/chapter08"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Volumes and Data</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#course-reading" class="table-of-contents__link toc-highlight">Course Reading</a><ul><li><a href="#learning-objectives" class="table-of-contents__link toc-highlight">Learning objectives</a></li><li><a href="#overview" class="table-of-contents__link toc-highlight">Overview</a></li><li><a href="#deployments" class="table-of-contents__link toc-highlight">Deployments</a></li><li><a href="#object-relationship" class="table-of-contents__link toc-highlight">Object relationship</a></li><li><a href="#deployment-details" class="table-of-contents__link toc-highlight">Deployment details</a></li><li><a href="#deployment-configuration-metadata" class="table-of-contents__link toc-highlight">Deployment configuration metadata</a></li><li><a href="#deployment-configuration-spec" class="table-of-contents__link toc-highlight">Deployment configuration spec</a></li><li><a href="#deployment-configuration-pod-template" class="table-of-contents__link toc-highlight">Deployment configuration Pod template</a></li><li><a href="#deployment-configuration-status" class="table-of-contents__link toc-highlight">Deployment configuration status</a></li><li><a href="#scaling-and-rolling-updates" class="table-of-contents__link toc-highlight">Scaling and rolling updates</a></li><li><a href="#deployment-rollbacks" class="table-of-contents__link toc-highlight">Deployment rollbacks</a></li><li><a href="#using-daemonsets" class="table-of-contents__link toc-highlight">Using DaemonSets</a></li><li><a href="#labels-1" class="table-of-contents__link toc-highlight">Labels</a></li></ul></li><li><a href="#lab-exercises" class="table-of-contents__link toc-highlight">Lab Exercises</a><ul><li><a href="#lab-71---working-with-replicasets" class="table-of-contents__link toc-highlight">Lab 7.1 - Working with ReplicaSets</a></li><li><a href="#lab-72---working-with-daemonsets" class="table-of-contents__link toc-highlight">Lab 7.2 - Working with DaemonSets</a></li><li><a href="#lab-73---rolling-updates-and-rollbacks" class="table-of-contents__link toc-highlight">Lab 7.3 - Rolling Updates and Rollbacks</a></li></ul></li><li><a href="#knowledge-check" class="table-of-contents__link toc-highlight">Knowledge check</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/cka-prep/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/andrewdaoust/cka-prep" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 Andrew D'Aoust. Built with Docusaurus.</div></div></div></footer></div>
<script src="/cka-prep/assets/js/runtime~main.12fc88c9.js"></script>
<script src="/cka-prep/assets/js/main.d9dff869.js"></script>
</body>
</html>