"use strict";(self.webpackChunkcka_prep_2=self.webpackChunkcka_prep_2||[]).push([[8572],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,h=p["".concat(s,".").concat(m)]||p[m]||u[m]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},7935:function(e,t,n){n.d(t,{o:function(){return i}});var a=n(7294);function i(e){return a.createElement("div",{style:{borderRadius:"10px"}},a.createElement(o,null),a.createElement(s,{lines:e.lines}))}function r(e){return a.createElement("div",{style:{backgroundColor:e.buttonColor,borderRadius:"100%",width:"10px",height:"10px",margin:"3px"}})}function o(){return a.createElement("div",{style:{display:"flex",backgroundColor:"#edeeef",padding:"6px",borderTopLeftRadius:"10px",borderTopRightRadius:"10px"}},a.createElement(r,{buttonColor:"#FF605C"}),a.createElement(r,{buttonColor:"#FFBD44"}),a.createElement(r,{buttonColor:"#00CA4E"}))}function l(e){var t=e.dir?e.dir:"~",n=e.node?e.node:"cp";return a.createElement("p",{style:{margin:"0px",padding:"2px"}},"ubuntu@"+n+":"+t+" $ "+e.text)}function s(e){console.log(e.lines);var t=e.lines.map((function(e){return a.createElement(l,{text:e.text,dir:e.dir})}));return a.createElement("div",{style:{backgroundColor:"black",color:"#00ff01",fontFamily:"monospace",borderBottomLeftRadius:"10px",borderBottomRightRadius:"10px",paddingTop:"5px",paddingBottom:"5px",paddingLeft:"4px",marginBottom:"10px"}},t)}},279:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return u},default:function(){return m}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=n(7935),l=["components"],s={id:"chapter14",title:"Custom Resource Definitions"},c=void 0,d={unversionedId:"fundamentals/chapter14",id:"fundamentals/chapter14",title:"Custom Resource Definitions",description:"Course Reading",source:"@site/docs/fundamentals/chapter14.mdx",sourceDirName:"fundamentals",slug:"/fundamentals/chapter14",permalink:"/cka-prep/docs/fundamentals/chapter14",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fundamentals/chapter14.mdx",tags:[],version:"current",frontMatter:{id:"chapter14",title:"Custom Resource Definitions"},sidebar:"tutorialSidebar",previous:{title:"Logging and Troubleshooting",permalink:"/cka-prep/docs/fundamentals/chapter13"},next:{title:"Security",permalink:"/cka-prep/docs/fundamentals/chapter15"}},u=[{value:"Course Reading",id:"course-reading",children:[{value:"Learning objectives",id:"learning-objectives",children:[],level:3},{value:"Custom Resources",id:"custom-resources",children:[],level:3},{value:"Custom resource definitions",id:"custom-resource-definitions",children:[{value:"Example",id:"example",children:[],level:4},{value:"Defining the new object",id:"defining-the-new-object",children:[],level:4}],level:3},{value:"Optional hooks",id:"optional-hooks",children:[{value:"Finalizer",id:"finalizer",children:[],level:4},{value:"Validation",id:"validation",children:[],level:4}],level:3},{value:"Understanding Aggregated APIs",id:"understanding-aggregated-apis",children:[],level:3}],level:2},{value:"Lab Exercises",id:"lab-exercises",children:[{value:"Lab 14.1 - Create a Custom Resource Definition",id:"lab-141---create-a-custom-resource-definition",children:[],level:3}],level:2},{value:"Knowledge check",id:"knowledge-check",children:[],level:2}],p={toc:u};function m(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"course-reading"},"Course Reading"),(0,r.kt)("h3",{id:"learning-objectives"},"Learning objectives"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Grow available Kubernetes objects"),(0,r.kt)("li",{parentName:"ul"},"Deploy a custom resource definition (CRD)"),(0,r.kt)("li",{parentName:"ul"},"Deploy a new resource and API endpoints"),(0,r.kt)("li",{parentName:"ul"},"Discuss aggregates APIs")),(0,r.kt)("h3",{id:"custom-resources"},"Custom Resources"),(0,r.kt)("p",null,"Kubernetes allows the flexibility to add your own dynamic resources to the cluster, outside the scope of those built-in.  Once a custom resource has been added, it can be created through the same methods of any other built-in resource, like with ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl"),"."),(0,r.kt)("p",null,"For a custom resource to be made part of the API, it needs a controller to receive the specification for that object and work to maintain the object in that state. These custom controllers should handle all the tasks a human would have to take if deploying the application outside of Kubernetes."),(0,r.kt)("p",null,"There are two methods for adding custom resource to the cluster that offer different levels of flexibility.  The less flexible option is to add a ",(0,r.kt)("strong",{parentName:"p"},"custom resource definition")," (CRD). The more flexible option is to add ",(0,r.kt)("strong",{parentName:"p"},"aggregated APIs")," (AA), which uses a new API server to be written and deployed in the cluster. Both options still manage custom resources outside the scope of the built-ins."),(0,r.kt)("p",null,"With RBAC, you will need to allow access to the new CRD resources and controller.  When using an AA, you can use the typical auth methods or a different one."),(0,r.kt)("h3",{id:"custom-resource-definitions"},"Custom resource definitions"),(0,r.kt)("p",null,"When a new API object and controller is added via CRDs, the existing kube-apiserver can be used to monitor and control the object's state. A CRD will add a new path to the API, under the ",(0,r.kt)("inlineCode",{parentName:"p"},"apiextensions.k8s.io/v1")," group."),(0,r.kt)("p",null,"CRDs are the easiest way to add a new type of object to the cluster, although it is less flexible. Only the existing API functionality can be used, objects must respond to RESTful requests, and their state must be validated and stored in the same way built-in API objects do."),(0,r.kt)("p",null,"CRDs also allow the new resources to be deployed in a namespace or cluster wide. The manifest uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"scope")," field and takes the value of either ",(0,r.kt)("inlineCode",{parentName:"p"},"Namespaced")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Cluster")," depending on how it should be deployed."),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  name: backups.stable.linux.com\nspec:\n  group: stable.linux.com\n  version: v1\n  scope: Namespaced\n  names:\n    plural: backups\n    singular: backup\n    shortNames:\n    - bks\n    kind: BackUp\n")),(0,r.kt)("p",null,"Let's walk through each part of this example"),(0,r.kt)("p",null,"Like any manifest, we begin with the ",(0,r.kt)("inlineCode",{parentName:"p"},"apiVersion"),", which for a CRD must be ",(0,r.kt)("inlineCode",{parentName:"p"},"apiextensions.k8s.io/v1"),"."),(0,r.kt)("p",null,"Next is the kind, which for a CRD is ",(0,r.kt)("inlineCode",{parentName:"p"},"CustomResourceDefinition"),"."),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata")," field, the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," must match the later defined spec.  It must have the structure of ",(0,r.kt)("inlineCode",{parentName:"p"},"<spec.names.plural>.<spec.group>"),"."),(0,r.kt)("p",null,"Next is the ",(0,r.kt)("inlineCode",{parentName:"p"},"group")," which is used to determine the endpoint in the API which is in the structure ",(0,r.kt)("inlineCode",{parentName:"p"},"/apis/<group>/<version>"),", which for this example specifically is ",(0,r.kt)("inlineCode",{parentName:"p"},"/apis/stable/v1"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"scope")," determines if the objects must exist in a namespace or be cluster-wide."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"plural")," field is what determines the end of the API url, so in this case it would be ",(0,r.kt)("inlineCode",{parentName:"p"},"/apis/stable/v1/backups"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"singular")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"shortName")," fields are used to make CLI easier.  This is the same ideas of being able to retrieve pods with ",(0,r.kt)("inlineCode",{parentName:"p"},"pods"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"pod")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"po"),"."),(0,r.kt)("p",null,"Finally, the ",(0,r.kt)("inlineCode",{parentName:"p"},"spec.kind")," field determines the camel cased name that would be used when writing a manifest for one of these objects."),(0,r.kt)("h4",{id:"defining-the-new-object"},"Defining the new object"),(0,r.kt)("p",null,"To then define the object the CRD creates would look something like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: "stable.linux.com/v1"\nkind: BackUp\nmetadata:\n  name: new-backup-object\nspec:\n  timeSpec: "* * * * */5"\n  image: linux-backup-image\nreplicas: 5\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"apiVersion")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"kind")," must match what is specified in the CRD.  The fields in ",(0,r.kt)("inlineCode",{parentName:"p"},"spec")," all depend on the associated controller. If the controller has validation, it would check the values to be what is expected and error if it does not match. With no validation, only the existence of the needed fields is checked."),(0,r.kt)("h3",{id:"optional-hooks"},"Optional hooks"),(0,r.kt)("h4",{id:"finalizer"},"Finalizer"),(0,r.kt)("p",null,"Just like built-in objects, an asynchronous pre-delete hook called a ",(0,r.kt)("inlineCode",{parentName:"p"},"Finalizer")," can be used.  When the API receives a ",(0,r.kt)("inlineCode",{parentName:"p"},"delete")," request, the ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata.deletionTimestamp")," field is updated and then the configured finalizer is run. When a finalizer completes, it is removed from the list and the next one is processed, until the list is empty."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"metadata:\n  finalizer:\n  - finalizer.stable.linux.com\n")),(0,r.kt)("h4",{id:"validation"},"Validation"),(0,r.kt)("p",null,"Validation for custom objects can also be done using the OpenAPI v3 schema. This will check the properties being passed in a manifest defining the resource."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"validation:\n  openAPIV3Schema:\n    properties:\n      spec:\n        properties:\n          timeSpec:\n            type: string\n            pattern: '^(\\d+|\\*)(/\\d+)?(\\s+(\\d+|\\*)(/\\d+)?){4}$'\n          replicas:\n            type: integer\n            minimum: 1\n            maximum: 10\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"timeSpec")," field must match a certain string pattern, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"replicas")," field must be an integer between 1 and 10."),(0,r.kt)("h3",{id:"understanding-aggregated-apis"},"Understanding Aggregated APIs"),(0,r.kt)("p",null,"Aggregated APIs allow adding more Kubernetes-like API servers to the cluster.  The additional servers are subordinate to the kube-apiserver, which will run the aggregation layer. Then when a new custom resource is requested, the aggregation layer will listen for any URLs and proxy them to the new API if it is responsible for that object."),(0,r.kt)("p",null,"The aggregation layer can be enabled by adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"enable-aggregator-routing=true")," flag to the kube-apiserver start-up commands."),(0,r.kt)("p",null,"Configuring TLS between components and RBAC rules is necessary."),(0,r.kt)("h2",{id:"lab-exercises"},"Lab Exercises"),(0,r.kt)("h3",{id:"lab-141---create-a-custom-resource-definition"},"Lab 14.1 - Create a Custom Resource Definition"),(0,r.kt)("p",null,"First view any existing CRDs on the cluster."),(0,r.kt)(o.o,{lines:[{text:"kubectl get crd --all-namespaces"}],mdxType:"Terminal"}),(0,r.kt)("p",null,"You should see they are all for the Calico network plugin we used when building the cluster as well as for linkerd. If you were to look at the ",(0,r.kt)("inlineCode",{parentName:"p"},"calico.yaml")," file we used when first building the cluster, you would see the ",(0,r.kt)("inlineCode",{parentName:"p"},"CustomResourceDefinition"),"s that where added."),(0,r.kt)(o.o,{lines:[{text:"cat calico.yaml"}],mdxType:"Terminal"}),(0,r.kt)("p",null,"Having looked at some exampled, let's build our own."),(0,r.kt)(o.o,{lines:[{text:"vim crd.yaml"}],mdxType:"Terminal"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  name: crontabs.stable.example.com\nspec:\n  group: stable.example.com\n  versions:\n  - name: v1\n    served: true\n    storage: true\n    schema:\n      openAPIV3Schema:\n        type: object\n        properties:\n          spec:\n            type: object\n            properties:\n              cronSpec:\n                type: string\n              image:\n                type: string\n              replicas:\n                type: integer\n  scope: Namespaced\n  names:\n    plural: crontabs\n    singular: crontabs\n    shortNames:\n    - ct\n    kind: CronTab\n")),(0,r.kt)("p",null,"Now create the CRD, view it among the others and describe it."),(0,r.kt)(o.o,{lines:[{text:"kubectl create -f crd.yaml"},{text:"kubectl get crd"},{text:"kubectl describe crd crontabs.stable.example.com"}],mdxType:"Terminal"}),(0,r.kt)("p",null,"Now, let's create a new ",(0,r.kt)("inlineCode",{parentName:"p"},"CronTab")," object.  Note that it will not do anything since there is no associated controller with this object."),(0,r.kt)(o.o,{lines:[{text:"vim crontab.yaml"}],mdxType:"Terminal"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: "stable.example.com/v1"\nkind: CronTab\nmetadata:\n  name: new-crontab\nspec:\n  cronSpec: "* */4 * * *"\n  # This image doesn\'t need to exist in this case\n  image: some-image\n')),(0,r.kt)(o.o,{lines:[{text:"kubectl create -f crontab.yaml"},{text:"kubectl get crontabs"},{text:"kubectl get ct"},{text:"kubectl describe ct"}],mdxType:"Terminal"}),(0,r.kt)("p",null,"You can then delete the CRD, which should also remove the API endpoints and all objects."),(0,r.kt)(o.o,{lines:[{text:"kubectl delete -f crd.yaml"},{text:"kubectl get ct"}],mdxType:"Terminal"}),(0,r.kt)("h2",{id:"knowledge-check"},"Knowledge check"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When adding a new API object to the kube-apiserver, we use a ",(0,r.kt)("strong",{parentName:"li"},"Custom Resource Definition")),(0,r.kt)("li",{parentName:"ul"},"When we add a new API server that is subordinate to the kube-apiserver, we use ",(0,r.kt)("strong",{parentName:"li"},"Aggregated APIs")),(0,r.kt)("li",{parentName:"ul"},"CRDs are ",(0,r.kt)("strong",{parentName:"li"},"not")," required to live in a namespace")))}m.isMDXComponent=!0}}]);