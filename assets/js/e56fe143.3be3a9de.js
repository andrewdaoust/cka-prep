"use strict";(self.webpackChunkcka_prep_2=self.webpackChunkcka_prep_2||[]).push([[2464],{3905:function(e,t,r){r.d(t,{Zo:function(){return d},kt:function(){return h}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(r),h=a,f=p["".concat(l,".").concat(h)]||p[h]||u[h]||i;return r?n.createElement(f,o(o({ref:t},d),{},{components:r})):n.createElement(f,o({ref:t},d))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},5857:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var n=r(7462),a=r(3366),i=(r(7294),r(3905)),o=["components"],s={id:"chapter09",title:"Services"},l=void 0,c={unversionedId:"fundamentals/chapter09",id:"fundamentals/chapter09",title:"Services",description:"Course Reading",source:"@site/docs/fundamentals/chapter09.md",sourceDirName:"fundamentals",slug:"/fundamentals/chapter09",permalink:"/cka-prep/docs/fundamentals/chapter09",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fundamentals/chapter09.md",tags:[],version:"current",frontMatter:{id:"chapter09",title:"Services"},sidebar:"tutorialSidebar",previous:{title:"Volumes and Data",permalink:"/cka-prep/docs/fundamentals/chapter08"},next:{title:"Helm",permalink:"/cka-prep/docs/fundamentals/chapter10"}},d=[{value:"Course Reading",id:"course-reading",children:[{value:"Learning objectives",id:"learning-objectives",children:[],level:3},{value:"Overview",id:"overview",children:[],level:3},{value:"Service update pattern",id:"service-update-pattern",children:[],level:3},{value:"Accessing an application with a service",id:"accessing-an-application-with-a-service",children:[],level:3},{value:"Types of services",id:"types-of-services",children:[{value:"ClusterIP",id:"clusterip",children:[],level:4},{value:"NodePort",id:"nodeport",children:[],level:4},{value:"LoadBalancer",id:"loadbalancer",children:[],level:4},{value:"ExternalName",id:"externalname",children:[],level:4},{value:"Ingress controllers",id:"ingress-controllers",children:[],level:4}],level:3},{value:"Services diagram",id:"services-diagram",children:[],level:3}],level:2}],u={toc:d};function p(e){var t=e.components,r=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"course-reading"},"Course Reading"),(0,i.kt)("h3",{id:"learning-objectives"},"Learning objectives"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Explain a Kubernetes service"),(0,i.kt)("li",{parentName:"ul"},"Expose an application"),(0,i.kt)("li",{parentName:"ul"},"Discuss the types of services available"),(0,i.kt)("li",{parentName:"ul"},"Start a local proxy"),(0,i.kt)("li",{parentName:"ul"},"Use the cluster DNS")),(0,i.kt)("h3",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Services are the agents connection Pods together or to allow access from outside the cluster. Typically via labels, and refreshed Pods are connected by the service so there is no change in the expected resources at a given Endpoint."),(0,i.kt)("p",null,"There are multiple types of services, each exposed internally or externally. Services also can be used to connect third party external resources, like a database, for example."),(0,i.kt)("p",null,"The kube-proxy operator watched the kube-apiserver for new services and endpoints. Random ports are opened listened on for traffic to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ClusterIP:Port")," and traffic is redirected to the randomly generated endpoint for the service. Services provide automatic load balancing, match label queries. This cannot be configured but there is possibility for session affinity via IP.  A headless service (without a fixed IP or load balancing) can be configured."),(0,i.kt)("p",null,"The unique IP addresses are configured via etcd, so Services implement iptables to route their traffic. Other technologies could be leveraged to provide access to resources later."),(0,i.kt)("h3",{id:"service-update-pattern"},"Service update pattern"),(0,i.kt)("p",null,"Labels on each Pod are used to determine what traffic should be received from a service. Labels can be dynamically updated on an object which can affect which Pods continue to connect to a service."),(0,i.kt)("p",null,"By default, the update pattern is to use a rolling deployment. New Pods are added with a new application version, and because of the automatic load balancing they will receive traffic along with the previous version of the application until the old version Pods are terminated."),(0,i.kt)("p",null,"If there would be an issue where routing traffic to a new and old version of an application during the update would cuase an issue, you may want to take the strategy where you use a more specific label for the new deployment, then turn down the old version, and update the labels to shift traffic to tie back to the original service."),(0,i.kt)("h3",{id:"accessing-an-application-with-a-service"},"Accessing an application with a service"),(0,i.kt)("p",null,"The basic steps for setting up access to a new service is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl expose deployment/nginx --port=80 --type=NodePort\nkubectl get svc\nkubectl get svc nginx -o yaml\n")),(0,i.kt)("p",null,"You could then hit the nginx server in your browser using the public IP and the port that was exposed with the service (you can find the public IP with a ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get pods -o wide")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get endpoints"),")."),(0,i.kt)("p",null,"Now let's discuss what we actually did to expose the service, step by step. First we used the ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl expose")," command to actually create the service.  This service used port 80 and chose a random port to use on the nodes.  You can pass a ",(0,i.kt)("inlineCode",{parentName:"p"},"port")," (which we did) and ",(0,i.kt)("inlineCode",{parentName:"p"},"targetPort"),". We also specified the type of service with the ",(0,i.kt)("inlineCode",{parentName:"p"},"--type=NodePort")," option."),(0,i.kt)("p",null,"Next we ran a ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get svc")," to list all the services and find the one we just created. We see it was created with an internal IP. The range of available cluster IPs and the range of ports that can be used are configurable in the API server startup options."),(0,i.kt)("p",null,"Finally we ran ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get svc nginx -o yaml")," to view the manifest for the service in YAML format."),(0,i.kt)("h3",{id:"types-of-services"},"Types of services"),(0,i.kt)("p",null,"Behind the scenes, a service is an operator in the kube-controller-manager which sends API calls through the kube-apiserver to the network plugin and kube-proxy Pods running on the nodes. The service operator also creates endpoint operators to query the ephemeral IP addresses of Pods with a specific label. These operators work together to manage the firewall rules of the cluster via iptables or ipvs."),(0,i.kt)("h4",{id:"clusterip"},"ClusterIP"),(0,i.kt)("p",null,"This is the default service used. It only provides access internally (except when manually creating an external endpoint). The range of ClusterIPs is defined in API server startup options."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl proxy")," creates a local service to access a ClusterIP, which is helpful in troubleshooting and development scenarios."),(0,i.kt)("h4",{id:"nodeport"},"NodePort"),(0,i.kt)("p",null,"NodePorts are useful for debugging or when static IPs are necessary, like for opening a particular address access through a firewall.  The NodePort range is defined in the cluster configuration."),(0,i.kt)("p",null,"Some of these services build upon each other. A ClusterIP service configures a persistent IP and then directs traffic sent to that address to existing Pods ephemeral addresses, but only within the cluster."),(0,i.kt)("p",null,"When a NodePort service is created, first a ClusterIP is created first. Then a high numbered port is created and a firewall rule is sent out so that traffic to this new port on any node will be sent to the persistent IP, and then the Pods."),(0,i.kt)("h4",{id:"loadbalancer"},"LoadBalancer"),(0,i.kt)("p",null,"The LoadBalancer service was created so requests could be passed through cloud providers.  Private clouds may also implement this service with a cloud provider plugin like CloudStack or OpenStack.  Even without cloud providers, the address is made available for public traffic and packets are spread among Pods in the deployment automatically."),(0,i.kt)("p",null,"LoadBalancers do not create load balancers. Instead, a NodePort is created and makes async requests to use a load balancer. If a listener sees the request, like would occur when using a cloud provider, one would then be created. If no listener sees the request then the status remains ",(0,i.kt)("em",{parentName:"p"},"pending")," since no load balancer responds to the API call."),(0,i.kt)("h4",{id:"externalname"},"ExternalName"),(0,i.kt)("p",null,"ExternalName is a newer service. It has no selectors, nor does it define ports or endpoints. It instead allows for an alias to be returned to an external service.  This redirect happens at the DNS level, not via proxy or forwarding. This type of service is useful for things not yet brought into the Kubernetes cluster. A simple future change will redirect traffic to the internal objects."),(0,i.kt)("h4",{id:"ingress-controllers"},"Ingress controllers"),(0,i.kt)("p",null,"Ingress controllers are not services but instead a microservice running within a Pod. They listen on a high port on whichever node the pod is running on, and then sends traffic to service based on the requested URL. Ingress controllers are not built-in, but they are often used with services to centralize traffic. Ingress controllers will be discussed further later."),(0,i.kt)("h3",{id:"services-diagram"},"Services diagram"))}p.isMDXComponent=!0}}]);