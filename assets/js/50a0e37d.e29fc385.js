"use strict";(self.webpackChunkcka_prep_2=self.webpackChunkcka_prep_2||[]).push([[7342],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||l;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,i=new Array(l);i[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var p=2;p<l;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9292:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var a=n(7462),o=n(3366),l=(n(7294),n(3905)),i=["components"],r={id:"chapter06",title:"API Objects"},s=void 0,p={unversionedId:"fundamentals/chapter06",id:"fundamentals/chapter06",title:"API Objects",description:"Course Reading",source:"@site/docs/fundamentals/chapter06.md",sourceDirName:"fundamentals",slug:"/fundamentals/chapter06",permalink:"/cka-prep/docs/fundamentals/chapter06",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fundamentals/chapter06.md",tags:[],version:"current",frontMatter:{id:"chapter06",title:"API Objects"},sidebar:"tutorialSidebar",previous:{title:"APIs and Access",permalink:"/cka-prep/docs/fundamentals/chapter05"},next:{title:"Managing State with Deployments",permalink:"/cka-prep/docs/fundamentals/chapter07"}},c=[{value:"Course Reading",id:"course-reading",children:[{value:"Learning objectives",id:"learning-objectives",children:[],level:3},{value:"Overview",id:"overview",children:[],level:3},{value:"<code>v1</code> API group",id:"v1-api-group",children:[{value:"Node",id:"node",children:[],level:4},{value:"Service account",id:"service-account",children:[],level:4},{value:"Resource Quota",id:"resource-quota",children:[],level:4},{value:"Endpoint",id:"endpoint",children:[],level:4}],level:3},{value:"Discovering API groups",id:"discovering-api-groups",children:[],level:3},{value:"Deploying an application",id:"deploying-an-application",children:[{value:"Deployment",id:"deployment",children:[],level:4},{value:"ReplicaSet",id:"replicaset",children:[],level:4},{value:"Pod",id:"pod",children:[],level:4}],level:3},{value:"DaemonSets",id:"daemonsets",children:[],level:3},{value:"StatefulSets",id:"statefulsets",children:[],level:3},{value:"Autoscaling",id:"autoscaling",children:[],level:3},{value:"Jobs",id:"jobs",children:[],level:3},{value:"RBAC",id:"rbac",children:[],level:3}],level:2},{value:"Lab Exercises",id:"lab-exercises",children:[{value:"Lab 6.1 - RESTful API access",id:"lab-61---restful-api-access",children:[],level:3},{value:"Lab 6.2 - Using the proxy",id:"lab-62---using-the-proxy",children:[],level:3},{value:"Lab 6.3 - Working with Jobs",id:"lab-63---working-with-jobs",children:[{value:"Create a Job",id:"create-a-job",children:[],level:4},{value:"Create a CronJob",id:"create-a-cronjob",children:[],level:4}],level:3}],level:2},{value:"Knowledge check",id:"knowledge-check",children:[],level:2}],d={toc:c};function u(e){var t=e.components,n=(0,o.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"course-reading"},"Course Reading"),(0,l.kt)("h3",{id:"learning-objectives"},"Learning objectives"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Explore API versions"),(0,l.kt)("li",{parentName:"ul"},"Discuss rapid change and development"),(0,l.kt)("li",{parentName:"ul"},"Deploy and configure an application using a Deployment"),(0,l.kt)("li",{parentName:"ul"},"Examine primitives for a self-healing application"),(0,l.kt)("li",{parentName:"ul"},"Scale an application")),(0,l.kt)("h3",{id:"overview"},"Overview"),(0,l.kt)("p",null,"This chapter will cover API objects.  We will learn about resources in the ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," API group. Objects move from ",(0,l.kt)("inlineCode",{parentName:"p"},"alpha")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"beta")," and then finally to ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," once they are considered stable."),(0,l.kt)("p",null,"DaemonSets ensure a Pod for every node.  StatefulSets stick a container to a node and act like a deployment.  These have both progressed to ",(0,l.kt)("inlineCode",{parentName:"p"},"apps/v1")," stability. Jobs and CronJobs have reached ",(0,l.kt)("inlineCode",{parentName:"p"},"batch/v1")," stability."),(0,l.kt)("p",null,"Role-Based Access Control (RBAC), which is essential to security, went from ",(0,l.kt)("inlineCode",{parentName:"p"},"v1alpha")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," stability in one release cycle."),(0,l.kt)("p",null,"Because Kubernetes is such a fast moving project, it is important to keep track of changes. Any changes could be important to ongoing administration of the cluster."),(0,l.kt)("p",null,"New feature tracking for Kubernetes can be found in ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/kubernetes/enhancements"},"this repo"),"."),(0,l.kt)("p",null,"Release notes can be found by reading through the change logs in the Kubernetes repo ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/kubernetes/kubernetes/tree/master/CHANGELOG"},"here"),". You can also search and filter through change logs on ",(0,l.kt)("a",{parentName:"p",href:"https://relnotes.k8s.io/"},"this site"),"."),(0,l.kt)("div",{className:"admonition admonition-important alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"important")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"Starting in ",(0,l.kt)("inlineCode",{parentName:"p"},"v1.16"),", depreciated API object versions respond with an error rather than being accepted. This is an important change from past behavior."))),(0,l.kt)("h3",{id:"v1-api-group"},(0,l.kt)("inlineCode",{parentName:"h3"},"v1")," API group"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," API group is no longer a single group, but a collection of groups for each main object category."),(0,l.kt)("p",null,"So far, through the lab exercises, we have seen a few objects from the ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," group.  Here's a recap of some of them:"),(0,l.kt)("h4",{id:"node"},"Node"),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"node")," represents a machine, either virtual or physical, that is part of the Kubernetes cluster. Using ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl get nodes")," will retrieve information about them. Scheduling on nodes can be turned on and off with ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl uncordon")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl cordon"),", respectively."),(0,l.kt)("h4",{id:"service-account"},"Service account"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"serviceaccounts")," provide an identifier for running processes in a Pod to access the kube-apiserver and perform actions that it is granted to do."),(0,l.kt)("h4",{id:"resource-quota"},"Resource Quota"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"resourcequotas")," are useful tools that allow you to define quotas per namespace.  An example would be if you want a namespace to only run a certain number of Pods, you can define a ",(0,l.kt)("inlineCode",{parentName:"p"},"resourcequotas")," manifest, create it with ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl")," and Kubernetes will then enforce the quota."),(0,l.kt)("h4",{id:"endpoint"},"Endpoint"),(0,l.kt)("p",null,"Generally, ",(0,l.kt)("inlineCode",{parentName:"p"},"endpoints")," are not managed by the administrator.  They represent the set of IPs for Pods matching a ",(0,l.kt)("inlineCode",{parentName:"p"},"service"),". They come in handy when you want to check that a service actually matches running Pods. If the endpoint is empty, that means there are no matching Pods and something is probably wrong with the service definition."),(0,l.kt)("h3",{id:"discovering-api-groups"},"Discovering API groups"),(0,l.kt)("p",null,"Each group name can be appended to the API URL to see details for that group.  For example, you could drill down to find specifics of the ",(0,l.kt)("inlineCode",{parentName:"p"},"apiregistration.k8s.io")," group with ",(0,l.kt)("inlineCode",{parentName:"p"},"https://k8scp:6443/apis/apiregistration.k8s.io/v1"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "kind": "APIResourceList",\n  "apiVersion": "v1",\n  "groupVersion": "apiregistration.k8s.io/v1",\n  "resources": [\n    {\n      "name": "apiservices",\n      "singularName": "",\n      "namespaced": false,\n      "kind": "APIService",\n      "verbs": [\n        "create",\n        "delete",\n        "deletecollection",\n        "get",\n        "list",\n        "patch",\n        "update",\n        "watch"\n      ],\n      "categories": [\n        "api-extensions"\n      ],\n      "storageVersionHash": "<omitted>"\n    },\n    {\n      "name": "apiservices/status",\n      "singularName": "",\n      "namespaced": false,\n      "kind": "APIService",\n      "verbs": [\n        "get",\n        "patch",\n        "update"\n      ]\n    }\n  ]\n}\n')),(0,l.kt)("p",null,"If you followed this, you would see just one resource, called ",(0,l.kt)("inlineCode",{parentName:"p"},"apiservices"),". IF it looks like it is listed twice, the lower is the status.  You'll also notice there are different verbs for each. Another entry is if the object is namespaced, or restricted to only one namespace.  In this case it is not."),(0,l.kt)("p",null,"To get a list of all the API groups you can run"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"curl --cert ./client.pem --key ./client-key.pem --cacert ./ca.pem https://k8scp:6443/apis\n")),(0,l.kt)("p",null,"and you'll see a response something like"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "kind": "APIGroupList",\n  "apiVersion": "v1",\n  "groups": [\n    {\n      "name": "apiregistration.k8s.io",\n      "versions": [\n        {\n          "groupVersion": "apiregistration.k8s.io/v1",\n          "version": "v1"\n        }\n      ],\n      "preferredVersion": {\n        "groupVersion": "apiregistration.k8s.io/v1",\n        "version": "v1"\n      }\n    },\n    ...\n}\n')),(0,l.kt)("p",null,"You can ",(0,l.kt)("inlineCode",{parentName:"p"},"curl")," each URI to get more information on each like which verbs are available and other characteristics."),(0,l.kt)("h3",{id:"deploying-an-application"},"Deploying an application"),(0,l.kt)("p",null,"Using ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl create")," we can quickly deploy an application to the cluster. We have looked at the Pods created running the application ",(0,l.kt)("inlineCode",{parentName:"p"},"nginx"),". If we look closer though, we will see a Deployment was created, which manages ReplicaSets, which in turn control the Pod."),(0,l.kt)("h4",{id:"deployment"},"Deployment"),(0,l.kt)("p",null,"This is a controller that manges the sate of ReplicaSets.  This higher level control give more flexibility for upgrades and administration.  Unless there is a good reason not to, use a Deployment."),(0,l.kt)("h4",{id:"replicaset"},"ReplicaSet"),(0,l.kt)("p",null,"These orchestrate the life cycles and updates of Pods.  ReplicaSets are new versions of Replication Controllers, the only difference being selector support."),(0,l.kt)("h4",{id:"pod"},"Pod"),(0,l.kt)("p",null,"As mentioned ad nauseam, these are the smallest unit that can be managed and interacted with in Kubernetes.  They run the application container and possibly any support containers."),(0,l.kt)("h3",{id:"daemonsets"},"DaemonSets"),(0,l.kt)("p",null,"DaemonSets are controllers that ensure Pods of the same type run on every cluster node.  When a new node is added to the cluster, a Pod that is the same sa all the others is started.  When the node is removed from the cluster, the DaemonSet ensures the Pod is deleted.  "),(0,l.kt)("p",null,"DaemonSets are most often used for logging, metrics, and security Pods. They can also be configured to avoid nodes."),(0,l.kt)("p",null,"As usual, you get all the normal CRUD operation with ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get daemonsets\nkubectl get ds\n")),(0,l.kt)("h3",{id:"statefulsets"},"StatefulSets"),(0,l.kt)("p",null,"A StatefulSet is an API object to manage stateful applications.  Pods deployed using StatefulSets use the same podSpec but they differ from a Deployment in that StatefulSets consider each Pod as unique and provides ordering in the deployment of Pods.  To track each Pod as a unique object, the controllers create an identity for the Pod composing of stable storage, stable network identity, and an ordinal.  This identity remains with the node, regardless of which node the Pod is running on at a given time."),(0,l.kt)("p",null,"By default, the deployment scheme is sequential, starting at 0 (e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"app-0"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"app-1"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"app-2"),", etc).  The next Pod is not launched until the previous reaches a running, steady state, not in parallel."),(0,l.kt)("p",null,"Since Kubernetes v1.9, StatefulSets have been stable."),(0,l.kt)("h3",{id:"autoscaling"},"Autoscaling"),(0,l.kt)("p",null,"In the autoscaling group, there is the ",(0,l.kt)("strong",{parentName:"p"},"Horizontal Pod Autoscaler (HPA)"),".  They automatically scale Replication Controllers, ReplicaSets, or Deployments to meet the target CPU usage (50% by default). The kubelet checks the usage every 30 seconds and the usage is retrieved by a Metrics Server API call every minute. The HPA checks the Metrics Server every 30 seconds as well.  If a Pod is added or removed, the HPA waits 3 minutes.  Other metrics are retrievable through REST calls. The autoscaler does not collect the metrics, but instead makes use of the aggregated information to increase and decrease replicas to match configuration."),(0,l.kt)("p",null,"The ",(0,l.kt)("strong",{parentName:"p"},"Cluster Autoscaler (CA)")," adds and removes cluster nodes. This is based on inability to deploy Pods or low utilization on a node for at least 10 minutes. Using the CA allows for dynamic request of resources from the cloud provider and minimizes cost for nodes not being used.  If using the CA, nodes should be added and removed with ",(0,l.kt)("inlineCode",{parentName:"p"},"cluster-autoscaler-")," commands. Scale up and down is checked every 10 seconds and decisions are made every 10 minutes.  If a scale down fails, the group is rechecked after 3 minutes, with the failing node being eligible in 5.  The time to allocate a new node is mostly dependent on the cloud provider."),(0,l.kt)("p",null,"There is another project, the ",(0,l.kt)("strong",{parentName:"p"},"Vertical Pod Autoscaler"),", which will adjust the amount of CPU and memory requested by Pods. This is still under development."),(0,l.kt)("h3",{id:"jobs"},"Jobs"),(0,l.kt)("p",null,"Jobs are part of the ",(0,l.kt)("inlineCode",{parentName:"p"},"batch")," API group and are used to run a defined number of Pods to completion. If a Pod fails, it is restarted until the number of completions is met."),(0,l.kt)("p",null,"Jobs can be seen as a way to do batch processing in Kubernetes but it can also be used for one-off Pods.  A Job spec will have a parallelism and completion key, and if omitted they are set to 1. If present, the parallelism number determines the number of Pods that can run concurrently. The completion number will set the number of Pods that need to run successfully for the Job to be considered complete. There are several patterns of implementation for Jobs, like traditional work queues."),(0,l.kt)("p",null,"Here is a simple example of a Job config:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="job.yaml"',title:'"job.yaml"'},'apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: pi\nspec:\n  template:\n    spec:\n      containers:\n      - name: pi\n        image: perl\n        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]\n      restartPolicy: Never\n  backoffLimit: 4\n')),(0,l.kt)("p",null,"There are also Cronjobs, which work similar to Linux jobs and use the same time syntax. Because there are cases where a job could not run during a time period, or because it could run twice, the requested Pod should be idempotent. An optional ",(0,l.kt)("inlineCode",{parentName:"p"},".spec.concurrencyPolicy")," can be supplied to determine how to handle existing jobs if the time segment expires.  If it is set to ",(0,l.kt)("inlineCode",{parentName:"p"},"Allow")," (which is the default), another concurrent job will be run. If it is set to ",(0,l.kt)("inlineCode",{parentName:"p"},"Forbid")," the current job continues and the new job is skipped. If ",(0,l.kt)("inlineCode",{parentName:"p"},"Replace")," is the value, the current job is cancelled and a new one takes its place."),(0,l.kt)("h3",{id:"rbac"},"RBAC"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"rbac.authorization.k8s.io")," group has four important resources:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"ClusterRole"),(0,l.kt)("li",{parentName:"ul"},"Role"),(0,l.kt)("li",{parentName:"ul"},"ClusterRoleBinding"),(0,l.kt)("li",{parentName:"ul"},"RoleBinding")),(0,l.kt)("p",null,"They are used for Role-based access control (RBAC). These resources allow us to define Roles in the cluster and associate users with the roles.  For example, we could create roles with some of the following permissions:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Read-only access to Pods in a specific namespace"),(0,l.kt)("li",{parentName:"ul"},"Access to create deployments, but not services")),(0,l.kt)("p",null,"We will come back to RBAC when we discuss security."),(0,l.kt)("h2",{id:"lab-exercises"},"Lab Exercises"),(0,l.kt)("h3",{id:"lab-61---restful-api-access"},"Lab 6.1 - RESTful API access"),(0,l.kt)("p",null,"This lab will continue focusing on access to the cp of the cluster. One authentication method is the use of a ",(0,l.kt)("inlineCode",{parentName:"p"},"Bearer token"),".  We'll work with one and also deploy a local proxy for application-level Kubernetes API access."),(0,l.kt)("p",null,"We'll again us ",(0,l.kt)("inlineCode",{parentName:"p"},"curl")," to make insecure API requests.  We need to find the IP and port, and then the token so we can retrieve the cluster data using REST calls. By default, most of the information is restricted, but changes to the authentication policy can allow more access."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"First we will find the IP and port number. On the cp node, run")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl config view\n")),(0,l.kt)("p",null,"and at the top you should see something like "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data: DATA+OMITTED\n    server: https://k8scp:6443\n  name: kubernetes\n")),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},"Next we will find the bearer token. We can do this by listing secrets in all namespaces or just the default one.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get secrets -A\nkubectl get secrets\n")),(0,l.kt)("p",null,"Listing the secrets in all namespaces you will see a secret for each of the cluster's controllers."),(0,l.kt)("p",null,"Now we can look at the details of the secret in the ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," namespace."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl describe secret default-token-<postfix>\n")),(0,l.kt)("p",null,"Now extract the token from the ",(0,l.kt)("inlineCode",{parentName:"p"},"token")," field from the ",(0,l.kt)("inlineCode",{parentName:"p"},"describe")," output."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"export token=$(kubectl describe secret default-token-<postfix> | grep ^token | cut -f7 -d ' ')\necho $token\n")),(0,l.kt)("ol",{start:3},(0,l.kt)("li",{parentName:"ol"},"Now we can test to try and get basic information from the cluster.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'curl https://k8scp:6443/apis --header "Authorization: Bearer $token" -k\n')),(0,l.kt)("p",null,"We use the ",(0,l.kt)("inlineCode",{parentName:"p"},"-k")," flag to avoid passing a cert."),(0,l.kt)("p",null,"Now try the API v1 group endpoint."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'curl https://k8scp:6443/api/v1 --header "Authorization: Bearer $token" -k\n')),(0,l.kt)("p",null,"This should return successfully. Now try to list the namespaces on the cluster."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'curl https://k8scp:6443/api/v1/namespaces --header "Authorization: Bearer $token" -k\n')),(0,l.kt)("p",null,"This should fail with an error. The error message tells us the request was seen as ",(0,l.kt)("inlineCode",{parentName:"p"},"system:serviceaccount")," which does not have RBAC authorization to list all namespaces in the cluster."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "kind": "Status",\n  "apiVersion": "v1",\n  "metadata": {},\n  "status": "Failure",\n  "message": "namespaces is forbidden: User \\"system:serviceaccount:default:default\\" cannot list resource \\"namespaces\\" in API group \\"\\" at the cluster scope",\n  "reason": "Forbidden",\n  "details": {\n    "kind": "namespaces"\n  },\n  "code": 403\n}\n')),(0,l.kt)("ol",{start:4},(0,l.kt)("li",{parentName:"ol"},"Pods also can make use of included certs. They are automatically made available in ",(0,l.kt)("inlineCode",{parentName:"li"},"/var/run/secrets/kubernetes.io/serviceaccount/")," on the Pod filesystem.  We will deploy a simple Pod and then we can confirm the token file on the container is the same as what we set in thr ",(0,l.kt)("inlineCode",{parentName:"li"},"token")," variable.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl run -it busybox --image=busybox --restart=Never\n")),(0,l.kt)("p",null,"Then on the shell of the container run"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"ls /var/run/secrets/kubernetes.io/serviceaccount/\ncat /var/run/secrets/kubernetes.io/serviceaccount/token\nexit\n")),(0,l.kt)("p",null,"Then delete to Pod to free up resources."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete pod busybox\n")),(0,l.kt)("h3",{id:"lab-62---using-the-proxy"},"Lab 6.2 - Using the proxy"),(0,l.kt)("p",null,"Now we will access the API vis a proxy.  The proxy can run on a node or from within a Pod using a sidecar. We will deploy a proxy listening on a loopback address  and then use ",(0,l.kt)("inlineCode",{parentName:"p"},"curl")," to access the cluster. "),(0,l.kt)("p",null,"For troubleshooting, if ",(0,l.kt)("inlineCode",{parentName:"p"},"curl")," works, but not from outside the cluster, we have narrowed down the issue to authentication/authorization and not issues further down in the API ingestion process."),(0,l.kt)("p",null,"First, we can view how to use the ",(0,l.kt)("inlineCode",{parentName:"p"},"proxy")," command in ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl proxy --help\n")),(0,l.kt)("p",null,"And then we can actually create the proxy and set it to the background.  make note of the process ID so we can stop it later."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl proxy --api-prefix=/ &\n")),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"The process ID will be the first line of the response followed by the endpoint for the endpoint that proxy will be listening on. In this example, it is ",(0,l.kt)("inlineCode",{parentName:"p"},"18050")),(0,l.kt)("pre",{parentName:"div"},(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"[1] 18050\nStarting to serve on 127.0.0.1:8001\n")))),(0,l.kt)("p",null,"Now we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"curl")," as we did before in the last lab section, this time without the token."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"curl http://127.0.0.1:8001/api/\ncurl http://127.0.0.1:8001/api/v1/namespaces\n")),(0,l.kt)("p",null,"Notice that this time, when you ",(0,l.kt)("inlineCode",{parentName:"p"},"curl")," the endpoint to  list the namespaces, it works. This is because the proxy is making the request on our behalf and has the correct permissions."),(0,l.kt)("p",null,"Finally we can turn the proxy down using the process ID we took note of before."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kill 18050\n")),(0,l.kt)("h3",{id:"lab-63---working-with-jobs"},"Lab 6.3 - Working with Jobs"),(0,l.kt)("h4",{id:"create-a-job"},"Create a Job"),(0,l.kt)("p",null,"While most API objects are deployed so that they are continually available, sometimes you may have ones that you want to run a set number of times (a ",(0,l.kt)("inlineCode",{parentName:"p"},"Job"),"), or on a regular basis (a ",(0,l.kt)("inlineCode",{parentName:"p"},"CronJob"),")."),(0,l.kt)("p",null,"First lets create a Job.  This one is very simple, as it just sleeps for three seconds then stops."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"vim job.yaml\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="job.yaml"',title:'"job.yaml"'},'apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: sleepy\nspec:\n  template:\n    spec:\n      containers:\n      - name: resting\n        image: busybox\n        command: ["/bin/sleep"]\n        args: ["3"]\n      restartPolicy: Never\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create -f job.yaml\nkubectl get job\nkubectl describe job sleepy\nkubectl get job sleepy -o yaml\n")),(0,l.kt)("p",null,"If you run the ",(0,l.kt)("inlineCode",{parentName:"p"},"get jobs")," command fast enough you will see it has not completed yet. Wait 3 seconds, and you should see the ",(0,l.kt)("inlineCode",{parentName:"p"},"COMPLETIONS")," change to ",(0,l.kt)("inlineCode",{parentName:"p"},"1/1"),"."),(0,l.kt)("p",null,"The if you look at the config info for the job, we can see the three main parameters that affect how a Job will run.  In the output you should see ",(0,l.kt)("inlineCode",{parentName:"p"},"backoffLimit"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"completions"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"parallelism")," fields.  Let's delete the existing Job as it will just continue to ",(0,l.kt)("inlineCode",{parentName:"p"},"AGE")," in a completed state."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete job sleepy\n")),(0,l.kt)("p",null,"Now let's edit the ",(0,l.kt)("inlineCode",{parentName:"p"},"job.yaml")," file. Within the ",(0,l.kt)("inlineCode",{parentName:"p"},"spec")," section, add a line for that says ",(0,l.kt)("inlineCode",{parentName:"p"},"completions: 5"),". Edit the YAML with ",(0,l.kt)("inlineCode",{parentName:"p"},"vim"),", it should look like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="job.yaml"',title:'"job.yaml"'},'apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: sleepy\nspec:\n  completions: 5   # <-- Add this line\n  template:\n    spec:\n      containers:\n      - name: resting\n        image: busybox\n        command: ["/bin/sleep"]\n        args: ["3"]\n      restartPolicy: Never\n')),(0,l.kt)("p",null,"This will make the Job need to complete 5 times before it is completed."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create -f job.yaml\nkubectl get jobs.batch\nkubectl get pods\n")),(0,l.kt)("p",null,"If you continue to run ",(0,l.kt)("inlineCode",{parentName:"p"},"get pods")," you will see more ",(0,l.kt)("inlineCode",{parentName:"p"},"sleepy")," pods come up as the previous ones complete until all 5 are completed. If you continue to run ",(0,l.kt)("inlineCode",{parentName:"p"},"get jobs")," you will see ",(0,l.kt)("inlineCode",{parentName:"p"},"COMPLETIONS")," start as ",(0,l.kt)("inlineCode",{parentName:"p"},"0/5")," and end at ",(0,l.kt)("inlineCode",{parentName:"p"},"5/5"),"."),(0,l.kt)("p",null,"Then delete the job again."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete job sleepy\n")),(0,l.kt)("p",null,"Next we will add the ",(0,l.kt)("inlineCode",{parentName:"p"},"parallelism")," parameter to the yaml spec file and recreate the job again. Again, edit the YAML with vim, it should look like this"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="job.yaml"',title:'"job.yaml"'},'apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: sleepy\nspec:\n  completions: 5   \n  parallelism: 2   # <-- Add this line\n  template:\n    spec:\n      containers:\n      - name: resting\n        image: busybox\n        command: ["/bin/sleep"]\n        args: ["3"]\n      restartPolicy: Never\n')),(0,l.kt)("p",null,"Then create the Job."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create -f job.yaml\nkubectl get jobs\nkubectl get pods\n")),(0,l.kt)("p",null,"This time when you ",(0,l.kt)("inlineCode",{parentName:"p"},"get pods")," you will see 2 ",(0,l.kt)("inlineCode",{parentName:"p"},"sleepy")," Pods are running concurrently. When you ",(0,l.kt)("inlineCode",{parentName:"p"},"get jobs")," you should again see it start at ",(0,l.kt)("inlineCode",{parentName:"p"},"0/5")," and end in ",(0,l.kt)("inlineCode",{parentName:"p"},"5/5")," ",(0,l.kt)("inlineCode",{parentName:"p"},"COMPLETIONS"),"."),(0,l.kt)("p",null,"Now let's add the ",(0,l.kt)("inlineCode",{parentName:"p"},"activeDeadlineSeconds")," to the job spec and set it to ",(0,l.kt)("inlineCode",{parentName:"p"},"15"),".  The Job and all Pods will now run for 15 seconds, then stop.  We will also increase the sleep time to 5 so it doesn't expire on it's own."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"vim job.yaml\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="job.yaml"',title:'"job.yaml"'},'apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: sleepy\nspec:\n  completions: 5   \n  parallelism: 2   \n  activeDeadlineSeconds: 15  # <-- Add this line\n  template:\n    spec:\n      containers:\n      - name: resting\n        image: busybox\n        command: ["/bin/sleep"]\n        args: ["5"]   # <-- Update this line\n      restartPolicy: Never\n')),(0,l.kt)("p",null,"Then delete the Job and recreate it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete job sleepy\nkubectl create -f job.yaml\nkubectl get jobs\n")),(0,l.kt)("p",null,"You should see the Job run and get to ",(0,l.kt)("inlineCode",{parentName:"p"},"3/5")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"4/5")," completions within the 15 second allowed runtime and then see it ages without any more completions."),(0,l.kt)("p",null,"Get the YAML output for the job and take a look at the ",(0,l.kt)("inlineCode",{parentName:"p"},"status")," section at the bottom."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get job sleepy -o yaml\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'status:\n  conditions:\n  - lastProbeTime: "2022-05-09T14:54:54Z"\n    lastTransitionTime: "2022-05-09T14:54:54Z"\n    message: Job was active longer than specified deadline\n    reason: DeadlineExceeded\n    status: "True"\n    type: Failed\n  failed: 1\n  startTime: "2022-05-09T14:54:39Z"\n  succeeded: 4\n  uncountedTerminatedPods: {}\n')),(0,l.kt)("p",null,"See the the Job failed due to ",(0,l.kt)("inlineCode",{parentName:"p"},"DeadlineExceeded")," because the ",(0,l.kt)("inlineCode",{parentName:"p"},"Job was active longer than specified deadline"),"."),(0,l.kt)("p",null,"Finally delete the Job."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete jobs.batch sleepy\n")),(0,l.kt)("h4",{id:"create-a-cronjob"},"Create a CronJob"),(0,l.kt)("p",null,"CronJobs create watch loops to then create Jobs on your behalf when the time is true.  To start let's copy our ",(0,l.kt)("inlineCode",{parentName:"p"},"job.yaml")," file and then edit it in ",(0,l.kt)("inlineCode",{parentName:"p"},"vim"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"cp job.yaml cronjob.yaml\nvim cronjob.yaml\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="cronjob.yaml"',title:'"cronjob.yaml"'},'apiVersion: batch/v1beta1  # Update to v1beta1 from v1\nkind: CronJob              # Update to CronJob kind\nmetadata:\n  name: sleepy\nspec:\n  schedule: "*/2 * * * *"  # Gets a Linux style cronjob syntax\n  jobTemplate:             # New jobTemplate and spec fields. Existing template tabbed in twice below the new spec field\n    spec:\n      template:\n        spec:\n          containers:\n          - name: resting\n            image: busybox\n            command: ["/bin/sleep"]\n            args: ["5"]\n          restartPolicy: Never\n')),(0,l.kt)("p",null,"Now let's create the job. It will take 2 minutes for the CronJob to generate a new Job."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create -f cronjob.yaml\nkubectl get cronjobs.batch\nkubectl get jobs.batch\n")),(0,l.kt)("p",null,"You should see the CronJob has not run yet and not Jobs have been created if you run the ",(0,l.kt)("inlineCode",{parentName:"p"},"get")," commands before the 2 minute mark."),(0,l.kt)("p",null,"Wait two minutes and run the ",(0,l.kt)("inlineCode",{parentName:"p"},"get")," commands again."),(0,l.kt)("p",null,"You should see the ",(0,l.kt)("inlineCode",{parentName:"p"},"LAST SCHEDULE")," change and a list of complete jobs for them, respectively."),(0,l.kt)("p",null,"Now let's change the CronJob to terminate any Jobs that run for more than 10 seconds and make the ",(0,l.kt)("inlineCode",{parentName:"p"},"sleep")," run for 30 seconds to ensure it fails."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"vim cronjob.yaml\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="cronjob.yaml"',title:'"cronjob.yaml"'},'apiVersion: batch/v1beta1\nkind: CronJob\nmetadata:\n  name: sleepy\nspec:\n  schedule: "*/2 * * * *"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          activeDeadlineSeconds: 10  # Added this line\n          containers:\n          - name: resting\n            image: busybox\n            command: ["/bin/sleep"]\n            args: ["30"]   # Updated to 30 seconds\n          restartPolicy: Never\n')),(0,l.kt)("p",null,"Then delete the CronJob and recreate it and run through the get commands like before."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete cronjob sleepy\nkubectl create -f cronjob.yaml\nkubectl get cronjobs.batch\nkubectl get jobs.batch\n")),(0,l.kt)("p",null,"You should see that the Jobs never hit a complete state."),(0,l.kt)("p",null,"Delete the CronJob once you are done."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete cronjob sleepy\n")),(0,l.kt)("h2",{id:"knowledge-check"},"Knowledge check"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"All API versions should ",(0,l.kt)("strong",{parentName:"li"},"not")," be considered stable"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Deployments")," are the suggested object for deploying and scaling applications"),(0,l.kt)("li",{parentName:"ul"},"The following is Kubernetes objects from smallest to largest: ",(0,l.kt)("strong",{parentName:"li"},"Container, Pod, ReplicaSet, Deployment")),(0,l.kt)("li",{parentName:"ul"},"A DaemonSet runs ",(0,l.kt)("strong",{parentName:"li"},"one")," Pod per node"),(0,l.kt)("li",{parentName:"ul"},"Deployments handle scaling of an application based on administrative config.  ",(0,l.kt)("strong",{parentName:"li"},"Horizontal Pod Autoscaling")," scales resources based on CPU usage (50% by default)"),(0,l.kt)("li",{parentName:"ul"},"Jobs and CronJobs belong to the ",(0,l.kt)("strong",{parentName:"li"},"batch")," API group")))}u.isMDXComponent=!0}}]);