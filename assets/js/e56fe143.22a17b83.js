"use strict";(self.webpackChunkcka_prep_2=self.webpackChunkcka_prep_2||[]).push([[2464],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,v=u["".concat(l,".").concat(h)]||u[h]||p[h]||i;return n?r.createElement(v,o(o({ref:t},d),{},{components:n})):r.createElement(v,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5857:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return u}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={id:"chapter09",title:"Services"},l=void 0,c={unversionedId:"fundamentals/chapter09",id:"fundamentals/chapter09",title:"Services",description:"Course Reading",source:"@site/docs/fundamentals/chapter09.md",sourceDirName:"fundamentals",slug:"/fundamentals/chapter09",permalink:"/cka-prep/docs/fundamentals/chapter09",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fundamentals/chapter09.md",tags:[],version:"current",frontMatter:{id:"chapter09",title:"Services"},sidebar:"tutorialSidebar",previous:{title:"Volumes and Data",permalink:"/cka-prep/docs/fundamentals/chapter08"},next:{title:"Helm",permalink:"/cka-prep/docs/fundamentals/chapter10"}},d=[{value:"Course Reading",id:"course-reading",children:[{value:"Learning objectives",id:"learning-objectives",children:[],level:3},{value:"Overview",id:"overview",children:[],level:3},{value:"Service update pattern",id:"service-update-pattern",children:[],level:3},{value:"Accessing an application with a service",id:"accessing-an-application-with-a-service",children:[],level:3},{value:"Types of services",id:"types-of-services",children:[{value:"ClusterIP",id:"clusterip",children:[],level:4},{value:"NodePort",id:"nodeport",children:[],level:4},{value:"LoadBalancer",id:"loadbalancer",children:[],level:4},{value:"ExternalName",id:"externalname",children:[],level:4},{value:"Ingress controllers",id:"ingress-controllers",children:[],level:4}],level:3},{value:"Services diagram",id:"services-diagram",children:[],level:3},{value:"Overall network view",id:"overall-network-view",children:[],level:3},{value:"Local proxy for development",id:"local-proxy-for-development",children:[],level:3},{value:"DNS",id:"dns",children:[],level:3},{value:"Verifying DNS registration",id:"verifying-dns-registration",children:[],level:3}],level:2}],p={toc:d};function u(e){var t=e.components,s=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"course-reading"},"Course Reading"),(0,i.kt)("h3",{id:"learning-objectives"},"Learning objectives"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Explain a Kubernetes service"),(0,i.kt)("li",{parentName:"ul"},"Expose an application"),(0,i.kt)("li",{parentName:"ul"},"Discuss the types of services available"),(0,i.kt)("li",{parentName:"ul"},"Start a local proxy"),(0,i.kt)("li",{parentName:"ul"},"Use the cluster DNS")),(0,i.kt)("h3",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Services are the agents connection Pods together or to allow access from outside the cluster. Typically via labels, and refreshed Pods are connected by the service so there is no change in the expected resources at a given Endpoint."),(0,i.kt)("p",null,"There are multiple types of services, each exposed internally or externally. Services also can be used to connect third party external resources, like a database, for example."),(0,i.kt)("p",null,"The kube-proxy operator watched the kube-apiserver for new services and endpoints. Random ports are opened listened on for traffic to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ClusterIP:Port")," and traffic is redirected to the randomly generated endpoint for the service. Services provide automatic load balancing, match label queries. This cannot be configured but there is possibility for session affinity via IP.  A headless service (without a fixed IP or load balancing) can be configured."),(0,i.kt)("p",null,"The unique IP addresses are configured via etcd, so Services implement iptables to route their traffic. Other technologies could be leveraged to provide access to resources later."),(0,i.kt)("h3",{id:"service-update-pattern"},"Service update pattern"),(0,i.kt)("p",null,"Labels on each Pod are used to determine what traffic should be received from a service. Labels can be dynamically updated on an object which can affect which Pods continue to connect to a service."),(0,i.kt)("p",null,"By default, the update pattern is to use a rolling deployment. New Pods are added with a new application version, and because of the automatic load balancing they will receive traffic along with the previous version of the application until the old version Pods are terminated."),(0,i.kt)("p",null,"If there would be an issue where routing traffic to a new and old version of an application during the update would cuase an issue, you may want to take the strategy where you use a more specific label for the new deployment, then turn down the old version, and update the labels to shift traffic to tie back to the original service."),(0,i.kt)("h3",{id:"accessing-an-application-with-a-service"},"Accessing an application with a service"),(0,i.kt)("p",null,"The basic steps for setting up access to a new service is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl expose deployment/nginx --port=80 --type=NodePort\nkubectl get svc\nkubectl get svc nginx -o yaml\n")),(0,i.kt)("p",null,"You could then hit the nginx server in your browser using the public IP and the port that was exposed with the service (you can find the public IP with a ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get pods -o wide")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get endpoints"),")."),(0,i.kt)("p",null,"Now let's discuss what we actually did to expose the service, step by step. First we used the ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl expose")," command to actually create the service.  This service used port 80 and chose a random port to use on the nodes.  You can pass a ",(0,i.kt)("inlineCode",{parentName:"p"},"port")," (which we did) and ",(0,i.kt)("inlineCode",{parentName:"p"},"targetPort"),". We also specified the type of service with the ",(0,i.kt)("inlineCode",{parentName:"p"},"--type=NodePort")," option."),(0,i.kt)("p",null,"Next we ran a ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get svc")," to list all the services and find the one we just created. We see it was created with an internal IP. The range of available cluster IPs and the range of ports that can be used are configurable in the API server startup options."),(0,i.kt)("p",null,"Finally we ran ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl get svc nginx -o yaml")," to view the manifest for the service in YAML format."),(0,i.kt)("h3",{id:"types-of-services"},"Types of services"),(0,i.kt)("p",null,"Behind the scenes, a service is an operator in the kube-controller-manager which sends API calls through the kube-apiserver to the network plugin and kube-proxy Pods running on the nodes. The service operator also creates endpoint operators to query the ephemeral IP addresses of Pods with a specific label. These operators work together to manage the firewall rules of the cluster via iptables or ipvs."),(0,i.kt)("h4",{id:"clusterip"},"ClusterIP"),(0,i.kt)("p",null,"This is the default service used. It only provides access internally (except when manually creating an external endpoint). The range of ClusterIPs is defined in API server startup options."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl proxy")," creates a local service to access a ClusterIP, which is helpful in troubleshooting and development scenarios."),(0,i.kt)("h4",{id:"nodeport"},"NodePort"),(0,i.kt)("p",null,"NodePorts are useful for debugging or when static IPs are necessary, like for opening a particular address access through a firewall.  The NodePort range is defined in the cluster configuration."),(0,i.kt)("p",null,"Some of these services build upon each other. A ClusterIP service configures a persistent IP and then directs traffic sent to that address to existing Pods ephemeral addresses, but only within the cluster."),(0,i.kt)("p",null,"When a NodePort service is created, first a ClusterIP is created first. Then a high numbered port is created and a firewall rule is sent out so that traffic to this new port on any node will be sent to the persistent IP, and then the Pods."),(0,i.kt)("h4",{id:"loadbalancer"},"LoadBalancer"),(0,i.kt)("p",null,"The LoadBalancer service was created so requests could be passed through cloud providers.  Private clouds may also implement this service with a cloud provider plugin like CloudStack or OpenStack.  Even without cloud providers, the address is made available for public traffic and packets are spread among Pods in the deployment automatically."),(0,i.kt)("p",null,"LoadBalancers do not create load balancers. Instead, a NodePort is created and makes async requests to use a load balancer. If a listener sees the request, like would occur when using a cloud provider, one would then be created. If no listener sees the request then the status remains ",(0,i.kt)("em",{parentName:"p"},"pending")," since no load balancer responds to the API call."),(0,i.kt)("h4",{id:"externalname"},"ExternalName"),(0,i.kt)("p",null,"ExternalName is a newer service. It has no selectors, nor does it define ports or endpoints. It instead allows for an alias to be returned to an external service.  This redirect happens at the DNS level, not via proxy or forwarding. This type of service is useful for things not yet brought into the Kubernetes cluster. A simple future change will redirect traffic to the internal objects."),(0,i.kt)("h4",{id:"ingress-controllers"},"Ingress controllers"),(0,i.kt)("p",null,"Ingress controllers are not services but instead a microservice running within a Pod. They listen on a high port on whichever node the pod is running on, and then sends traffic to service based on the requested URL. Ingress controllers are not built-in, but they are often used with services to centralize traffic. Ingress controllers will be discussed further later."),(0,i.kt)("h3",{id:"services-diagram"},"Services diagram"),(0,i.kt)("p",null,"Controllers for services and endpoints run in the kube-controller-manager, and send API calls through the kube-apiserver. The kube-apiserver then talks to the network plugin to direct the agents on each node what to do. Each kube-proxy is also sent an API call to manage the firewall locally, which is typically iptables or ipvs. The kube-proxy mode is configured via a flag, ",(0,i.kt)("inlineCode",{parentName:"p"},"mode"),", set on initialization. The mode can be ",(0,i.kt)("inlineCode",{parentName:"p"},"iptables"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"IPVS"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"userspace"),"."),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"iptables")," mode, the API continually sends updates to the kube-proxy about changes to Services and Endpoints so rules can be updated as the objects are created, modified, and deleted."),(0,i.kt)("h3",{id:"overall-network-view"},"Overall network view"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"overall network view",src:n(450).Z,width:"561",height:"631"})),(0,i.kt)("h3",{id:"local-proxy-for-development"},"Local proxy for development"),(0,i.kt)("p",null,"When doing local development for an application, a quick way to check the service is to run a local proxy with ",(0,i.kt)("inlineCode",{parentName:"p"},"kubectl"),". It captures the shell (unless places in the background). When running, calls can be made to the API via ",(0,i.kt)("inlineCode",{parentName:"p"},"localhost")," and you can also reach the ClusterIP services via the API URLs.  The IP and port to listen on is configurable via command arguments.  To run a proxy:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl proxy\n")),(0,i.kt)("p",null,"This starts a proxy on ",(0,i.kt)("inlineCode",{parentName:"p"},"localhost")," and uses port ",(0,i.kt)("inlineCode",{parentName:"p"},"8001")," by default.  Then to access a service, name ",(0,i.kt)("inlineCode",{parentName:"p"},"example"),", we can use the URL ",(0,i.kt)("inlineCode",{parentName:"p"},"http://localhost8001/api/v1/namespaces/default/services/example"),". If the service port has a name, you'd append ",(0,i.kt)("inlineCode",{parentName:"p"},":<port name>")," to the end of the URL."),(0,i.kt)("h3",{id:"dns"},"DNS"),(0,i.kt)("p",null,"Since v1.13, CoreDNS has been the default DNS provided. CoreDNS allows for a large amount of flexibility. When a container starts, it runs a server for the zones it is configured to serve, then each server loads one or many plugin chains to provide additional functionality. Like other microservices, clients access it using a service, kube-dns."),(0,i.kt)("p",null,"The in=tree plugins provide most additional common functionality. It is a fairly easy process to write and enable other plugins for extended functionality."),(0,i.kt)("p",null,"Common plugins are used to provide metrics to Prometheus, for error logging, health checking of the application, among other things."),(0,i.kt)("h3",{id:"verifying-dns-registration"},"Verifying DNS registration"),(0,i.kt)("p",null,"To verify DNS setup and check services are being registered, the easiest way is to run a pod with a shell and networking tools, create a service, and then exec in to do DNS lookups."),(0,i.kt)("p",null,"Troubleshooting DNS in the cluster uses typical tools like nslookup, dig, nc, wireshark, etc.  The difference though is we are leveraging a service to access the DNS server, so we need to check labels and selectors in addition to standard network debugging."),(0,i.kt)("p",null,"Other steps, like checking the Network Policies and firewalls can also be done. These will be covered more in a later chapter."))}u.isMDXComponent=!0},450:function(e,t,n){t.Z=n.p+"assets/images/ch09-overall-network-view-7147d9c6448c79e019ee3a356c4c9f48.png"}}]);