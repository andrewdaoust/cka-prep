"use strict";(self.webpackChunkcka_prep_2=self.webpackChunkcka_prep_2||[]).push([[8957],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return m}});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=c(a),m=o,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||r;return a?n.createElement(h,s(s({ref:t},d),{},{components:a})):n.createElement(h,s({ref:t},d))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},4851:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var n=a(7462),o=a(3366),r=(a(7294),a(3905)),s=["components"],i={id:"chapter08",title:"Volumes and Data"},l=void 0,c={unversionedId:"fundamentals/chapter08",id:"fundamentals/chapter08",title:"Volumes and Data",description:"Course Reading",source:"@site/docs/fundamentals/chapter08.md",sourceDirName:"fundamentals",slug:"/fundamentals/chapter08",permalink:"/cka-prep/docs/fundamentals/chapter08",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fundamentals/chapter08.md",tags:[],version:"current",frontMatter:{id:"chapter08",title:"Volumes and Data"},sidebar:"tutorialSidebar",previous:{title:"Managing State with Deployments",permalink:"/cka-prep/docs/fundamentals/chapter07"},next:{title:"Services",permalink:"/cka-prep/docs/fundamentals/chapter09"}},d=[{value:"Course Reading",id:"course-reading",children:[{value:"Learning objectives",id:"learning-objectives",children:[],level:3},{value:"Overview",id:"overview",children:[],level:3},{value:"Introducing volumes",id:"introducing-volumes",children:[],level:3},{value:"Volume spec",id:"volume-spec",children:[],level:3},{value:"Volume types",id:"volume-types",children:[],level:3},{value:"Shared volume example",id:"shared-volume-example",children:[],level:3},{value:"Persistent volumes and claims",id:"persistent-volumes-and-claims",children:[{value:"Phases of persistent storage",id:"phases-of-persistent-storage",children:[],level:4}],level:3},{value:"Persistent Volume",id:"persistent-volume",children:[],level:3},{value:"Persistent Volume Claim",id:"persistent-volume-claim",children:[],level:3},{value:"Dynamic provisioning",id:"dynamic-provisioning",children:[],level:3},{value:"Using Rook for storage orchestration",id:"using-rook-for-storage-orchestration",children:[],level:3},{value:"Secrets",id:"secrets",children:[],level:3},{value:"Using secrets via environment variables",id:"using-secrets-via-environment-variables",children:[],level:3},{value:"Mounting secrets as volumes",id:"mounting-secrets-as-volumes",children:[],level:3},{value:"Portable data with ConfigMaps",id:"portable-data-with-configmaps",children:[],level:3}],level:2}],u={toc:d};function p(e){var t=e.components,i=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"course-reading"},"Course Reading"),(0,r.kt)("h3",{id:"learning-objectives"},"Learning objectives"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Understand and create persistent volumes"),(0,r.kt)("li",{parentName:"ul"},"Configure persistent volume claims"),(0,r.kt)("li",{parentName:"ul"},"Manage volume access modes"),(0,r.kt)("li",{parentName:"ul"},"Deploy applications with persistent data storage"),(0,r.kt)("li",{parentName:"ul"},"Discuss dynamic provisioning of storage"),(0,r.kt)("li",{parentName:"ul"},"Configure secrets and ConfigMaps")),(0,r.kt)("h3",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Traditionally container engines do not offer storage that outlasts the container, since the container is seen as transient.  This could potentially lead to data loss or the need for complex data storage schemes."),(0,r.kt)("p",null,"In Kubernetes, ",(0,r.kt)("strong",{parentName:"p"},"volumes")," share the lifetime of a Pod, not the containers in them.  If a container terminates, the next one still has the data. Volumes are directories, sometimes pre-populated, that is made available to the containers in a Pod.  Volume creation, backend storage, and the data/contents is dependent on the type of volume, of which there are many, which you can ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/storage/volumes/#volume-types"},"read about here"),", each with different configuration and dependencies."),(0,r.kt)("p",null,'There is an effort to adopt the Container Storage Interface (CSI) to reach an industry standard interface for container orchestration to allow access to arbitrary storage systems. Currently, all volume plug-ins are "in-tree", meaning they are built with the Kubernetes source code. A swap to an "out-of-tree" model means 3rd-parties just need to develop their own driver to allow their plugin to be containerized, replacing the Flex plugin which has major security concerns.'),(0,r.kt)("p",null,"Sometimes you may also want the storage to have a lifetime that exceeds a Pod as well, and for this ",(0,r.kt)("strong",{parentName:"p"},"persistent volumes")," are used.  These allow volumes to out live Pods, and then be claimed by Pods with a Persistent Volume Claim. If one Pod is terminated, another one can come along and claim the persistent volume."),(0,r.kt)("p",null,"Two API object previously seen to pass data to Pods are ConfigMaps (for non-encoded data) and Secrets (for encoded data). These two object let you easily pass things like SSH keys, passwords, or configuration to the Pods, just to name a few use cases."),(0,r.kt)("h3",{id:"introducing-volumes"},"Introducing volumes"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"object relationship",src:a(2529).Z,width:"2550",height:"3300"})),(0,r.kt)("p",null,"Volumes can be defined in podSpec and where they are made available.  Each volume configuration requires a name, type, and mount point.One volume can be made available to multiple containers within the Pod, and this can be used as method of communication between containers.  Volumes can also be made available to multiple Pods, and each Pod has access to write to the volume.  Volumes have no concurrency checking, so the potential for corruption when enabling a volume for access from multiple Pods is high unless there is an outside mechanism to lock changes when others are in progress."),(0,r.kt)("p",null,"An access mode is part of the Pod request. As a request, more access may be granted, but not less, and an exact match is attempted to be made.  The cluster groups all the volumes from the requested mode and sorts from smallest to largest.  The claim is then checked against the list for the mode until one of sufficient size is found.  There are three access modes.:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"ReadWriteOnce")," allows read-write by a single node"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"ReadOnlyMany")," allows read only access by multiple nodes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"ReadWriteMany")," allows read-write access by multiple nodes")),(0,r.kt)("p",null,"Two Pods on the same node can write to a volume that has a ReadWriteOnce access mode, but a Pod on another node would not become ready if trying to attach to that volume due to a ",(0,r.kt)("inlineCode",{parentName:"p"},"FailedAttachVolume")," error."),(0,r.kt)("p",null,"When a volume is requested, the local kubelet run the ",(0,r.kt)("inlineCode",{parentName:"p"},"kubelet_pods.go")," script to get a map of all the devices, determine and create mount points for containers, and then create the symlink on the host node file system to associate the storage to the container.  The API server requests the storage from the ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageClass")," plugin."),(0,r.kt)("p",null,"If a request for a StorageClass was not made, only the parameters for access mode and size will be used. The volume could come from any of the storage options available, there is no configuration to determine which of the available will be used."),(0,r.kt)("h3",{id:"volume-spec"},"Volume spec"),(0,r.kt)("p",null,"On of many types of storage options in Kubernetes is the ",(0,r.kt)("inlineCode",{parentName:"p"},"emptyDir"),". The kubelet creates a directory in the container, but does not mount any storage.  Any data is written to the shared container space, and as a result is not persistent. When a Pod is destroyed, the data is deleted with the container."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: test-pd\nspec:\n  containers:\n  - image: k8s.gcr.io/test-webserver\n    name: test-container\n    volumeMounts:\n    - mountPath: /cache\n      name: cache-volume\n  volumes:\n  - name: cache-volume\n    emptyDir: {}\n")),(0,r.kt)("p",null,"The YAML above creates a single container Pod with a volume, named ",(0,r.kt)("inlineCode",{parentName:"p"},"cache-volume"),", which would be created in the ",(0,r.kt)("inlineCode",{parentName:"p"},"/cache")," directory in the container."),(0,r.kt)("h3",{id:"volume-types"},"Volume types"),(0,r.kt)("p",null,"There are quite a few different volume type that can be used, some using local storage, others using networked resources."),(0,r.kt)("p",null,"For GCE, AWS, and Azure, there were the ",(0,r.kt)("inlineCode",{parentName:"p"},"gcePersistentDisk"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"awsElasticBlockStore"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"azureDisk")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"azureFile"),", all of these not being depreciated, replaced with new out-of-tree plugins being in alpha or beta that use the new CSI features."),(0,r.kt)("p",null,"There are ",(0,r.kt)("inlineCode",{parentName:"p"},"emptyDir")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"hostPath")," volumes which are easy to use. The ",(0,r.kt)("inlineCode",{parentName:"p"},"emptyDir")," was already discussed. The ",(0,r.kt)("inlineCode",{parentName:"p"},"hostPath")," volume type mounts a resource from the host node filesystem. The resource could be a directory, file socket, character, or block device.  The resource must already exist on the host to be used, and there are two types, ",(0,r.kt)("inlineCode",{parentName:"p"},"DirectoryOrCreate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"FileOrCreate"),", which create the resource on the host and then use them if they do not exist already."),(0,r.kt)("p",null,"For scenarios with multiple readers a network file system (",(0,r.kt)("inlineCode",{parentName:"p"},"nfs"),") or a Internet Small Computer System Interface (",(0,r.kt)("inlineCode",{parentName:"p"},"iscsi"),") are easy choices."),(0,r.kt)("p",null,"For multiple writers good choices are ",(0,r.kt)("inlineCode",{parentName:"p"},"rdb")," for a block storage option, or ",(0,r.kt)("inlineCode",{parentName:"p"},"cephfs")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"glusterfs")," if either are configured on the cluster."),(0,r.kt)("p",null,"All available volume types can be read about on the official ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/storage/volumes/"},"Kubernetes docs page"),"."),(0,r.kt)("p",null,"The CSI allows for more flexibility and decoupling plugins from the Kubernetes source code. It exists so that arbitrary plugins can be exposed more easily in the future."),(0,r.kt)("h3",{id:"shared-volume-example"},"Shared volume example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"...\n  containers:\n  - name: alphacont\n    image: busybox\n    volumeMounts:\n    - mountPath: /alphadir\n      name: sharevol\n  - name: betacont\n    image: busybox\n    volumeMounts:\n    - mountPath: /betadir\n      name: sharevol\n  volumes:\n  - name: sharevol\n    emptyDir: {} \n")),(0,r.kt)("p",null,"The snipping from the YAML above would produce a Pod named ",(0,r.kt)("inlineCode",{parentName:"p"},"exampleA")," that has two containers both with access to a volume, ",(0,r.kt)("inlineCode",{parentName:"p"},"sharevol"),". An ",(0,r.kt)("inlineCode",{parentName:"p"},"emptyDir")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"hostPath")," could both easily be used here since both require no additional setup."),(0,r.kt)("p",null,"If the Pod was created and then the following commands are run"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl exec -it exampleA -c betacont -- touch /betadir/foobar\nkubectl exec -it exampleA -c alphacont -- ls -l /alphadir\n")),(0,r.kt)("p",null,"you should see a ",(0,r.kt)("inlineCode",{parentName:"p"},"foobar")," file in the ",(0,r.kt)("inlineCode",{parentName:"p"},"alphadir")," even though the other container wrote the data.  The containers have immediate access to any data the either of them write to the shared volume, and there is nothing stopping them from overwriting each others data. Locking or versioning of the data written by the containers must be considered and implemented into the containerized application to avoid issues with corrupted data."),(0,r.kt)("h3",{id:"persistent-volumes-and-claims"},"Persistent volumes and claims"),(0,r.kt)("p",null,"A persistent volume (pv) is another storage abstraction used to give data a lifetime that exceeds that of a Pod. Pods define a volume that used the type ",(0,r.kt)("inlineCode",{parentName:"p"},"persistentVolumeClaim")," (",(0,r.kt)("inlineCode",{parentName:"p"},"pvc"),"). The pvc has various parameters to define the size and the type of backend storage, known as the ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageClass"),".  The cluster then attached the ",(0,r.kt)("inlineCode",{parentName:"p"},"persistentVolume"),".  The cluster will dynamically use volumes that are available, irrespective of the storage type, allowing the claims to use ay backend storage."),(0,r.kt)("h4",{id:"phases-of-persistent-storage"},"Phases of persistent storage"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Provisioning")," of the persistent volumes can take a few forms. For example, they could be defined ahead of time by the administrator of the cluster, or they might dynamically be created, say by a request from a cloud provider."),(0,r.kt)("p",null,"A ",(0,r.kt)("strong",{parentName:"p"},"binding")," operation occurs when a watch loop see a new PVC, which contains the storage size, access request, and optionally, a ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageClass"),".  The controller locates a PV that matches this request, or it may have to wait for the ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageClass")," provisioner to create a new one.  The PV must meet the requested storage size, but it could contain more if only larger PV are available."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use")," of the PV begins when the volume is mounted to a Pod and continues through the lifetime of that Pod."),(0,r.kt)("p",null,"When the Pod is done with the volume and an API request is sent, the PVC is deleted and the volume is said to be ",(0,r.kt)("strong",{parentName:"p"},"released"),".  The volume remains in the same state from when the claim was deleted until it available to a new claim.  The data on the volume is retained depending on the defined ",(0,r.kt)("inlineCode",{parentName:"p"},"persistentVolumeReclaimPolicy"),"."),(0,r.kt)("p",null,"Volumes are ",(0,r.kt)("strong",{parentName:"p"},"reclaimed")," when one of three options happen:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("strong",{parentName:"li"},"retain"),", which keeps the data and allows the admin to handle the storage and data."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("strong",{parentName:"li"},"delete"),", removing the API object and the associated storage."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("strong",{parentName:"li"},"recycle"),", which runs a ",(0,r.kt)("inlineCode",{parentName:"li"},"rm -rf /mountpoint")," and then makes the volume available to a new claim.  With dynamic provisioning reaching good stability, this is intended to be depreciated.")),(0,r.kt)("p",null,"Like with other API object, PVs and PVCs can be viewed and described with ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pv\nkubectl get pvc\n")),(0,r.kt)("h3",{id:"persistent-volume"},"Persistent Volume"),(0,r.kt)("p",null,"Here is a basic example of a PV declaration that uses a ",(0,r.kt)("inlineCode",{parentName:"p"},"hostPath")," as the storage type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'kind: PersistentVolume\napiVersion: v1\nmetadata:\n  name: 10Gpv01\n  labels: \n    type: local \nspec:\n  capacity: \n    storage: 10Gi\n  accessModes:\n  - ReadWriteOnce\n  hostPath:\n    path: "/somepath/data01"\n')),(0,r.kt)("p",null,"Each storage type has its own configuration settings.  An example would be a Ceph or GE Persistent Disk that already exists, so it would not need to be configured and would just need to be claimed from the provider."),(0,r.kt)("p",null,"PVs are not namespaced objects, but PVCs are. Stable as of v1.18, Raw Block Volumes are allowed to be statically provisioned, supporting a handful of different volume plugins, which you can find ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#raw-block-volume-support"},"an up-to-date list of here"),"."),(0,r.kt)("p",null,"Locally attached storage is also a stable feature, often used as a part of distributed file systems or for databases."),(0,r.kt)("h3",{id:"persistent-volume-claim"},"Persistent Volume Claim"),(0,r.kt)("p",null,"Once a PV has been created in the cluster, a manifest for a claim can be written and the claim used by a Pod definition.  In the Pod, the volume is a ",(0,r.kt)("inlineCode",{parentName:"p"},"persistentVolumeClaim"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"title={Persistent Volume Claim manifest}",title:"{Persistent",Volume:!0,Claim:!0,"manifest}":!0},"kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: myclaim\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 8GI\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"title={Pod manifest using PVC}",title:"{Pod",manifest:!0,using:!0,"PVC}":!0},"...\n  spec:\n    containers:\n    ...\n    volumes:\n    - name: test-volume\n      persistentVolumeClaim:\n        claimName: myclaim\n")),(0,r.kt)("p",null,"That example is rather simple. A more complex configuration might look like"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"title={Complex PVC usage}",title:"{Complex",PVC:!0,"usage}":!0},"...\n  volumeMounts:\n  - name: Cephpd\n    mountPath: /data/rbd\n  volumes:\n  - name: rbdpd\n    rbd:\n      monitors:\n      - '10.19.14.22:6789'\n      - '10.19.14.23:6789'\n      - '10.19.14.24:6789'\n      pool: k8s\n      image: client\n      fsType: ext4\n      readOnly: true\n      user: admin\n      keyring: /etc/ceph/keyring\n      imageformat: \"2\"\n      imagefeatures: \"layering\"\n")),(0,r.kt)("h3",{id:"dynamic-provisioning"},"Dynamic provisioning"),(0,r.kt)("p",null,"Using persistent volumes and abstracting that storage with a claim were very powerful, but it originally required an administrator to create them.  Starting in Kubernetes v1.4, dynamic provisioning was added so that a cluster could request storage from an external, pre-configured source.  "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageClass")," API resources lets admins define a persistent volume provisioner. This is of a certain type with storage specific configuration.  Once created, users can request a claim from the ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageClass"),", and the API fills this via auto-provisioning. The resource will be reclaimed as configured by the provider.  Common choices from dynamic storage are AWS and GCE, and there are other options like a Ceph cluster or iSCSI."),(0,r.kt)("p",null,"This is an example of an AWS ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageClass")," using gp2 storage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\n  name: gp2\n  annotations:\n    storageclass.kubernetes.io/is-default-class: "true"\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: gp2\n  fsType: ext4\n')),(0,r.kt)("h3",{id:"using-rook-for-storage-orchestration"},"Using Rook for storage orchestration"),(0,r.kt)("p",null,"Rook is a project that allows for orchestration of storage by multiple providers. As with other agents within Kubernetes, Rook uses custom resource definitions (CRD) and a custom operator to handle the provisioning of storage according to backend storage type.  Currently several storage providers are supported, such as Ceph, Cassandra, and Network File System (NFS)."),(0,r.kt)("p",null,"You can learn more about the project ",(0,r.kt)("a",{parentName:"p",href:"https://rook.io/"},"here"),"."),(0,r.kt)("h3",{id:"secrets"},"Secrets"),(0,r.kt)("p",null,"For data you don't want readable to the naked eye, like a password, you can use secrets. Secret API resources can take this data and encode or encrypt it so it is not easily readable."),(0,r.kt)("p",null,"You can create, get, and delete secrets like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create secret generic --help\nkubectl create secret generic mysql --from-literal=password=root\nkubectl get secrets\nkubectl delete secret mysql\n")),(0,r.kt)("p",null,"Secrets are not encrypted by default, but instead are base64 encoded. To encrypt secrets you must create an ",(0,r.kt)("inlineCode",{parentName:"p"},"EncryptionConfiguration")," with a key and proper identity.  Then the kube-apiserver needs to have the ",(0,r.kt)("inlineCode",{parentName:"p"},"--encryption-provider-flag")," enabled to a previously configured provider (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"aescbc")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ksm"),"). Once enabled, every secret must be recreated since the encryption happens on the write."),(0,r.kt)("p",null,"You can have multiple keys, each is tried during decryption.  The first key of the first provider is used to encrypt secrets. To rotate them, create a new key, restart all kube-apiserver processes, and then recreate all secrets."),(0,r.kt)("p",null,"The encoded string in the secret can be viewed with ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl"),".  The secret is decoded and saved as a string to file, which can be used as an environment variable or in a new directory, similar to how a volume is mounted."),(0,r.kt)("p",null,"Secrets can be made manually with a manifest as well by pasting the encoded string into the manifest.  Here is an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"echo LFTr@1n | base64\nvim secret.yaml\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"title={secret.yaml}",title:"{secret.yaml}"},"apiVersion: v1\nkind: Secret\nmetadata:\n  name: lf-secret\ndata:\n  password: TEZUckAxbgo=\n")),(0,r.kt)("p",null,"where the output of the ",(0,r.kt)("inlineCode",{parentName:"p"},"echo")," command is entered as the ",(0,r.kt)("inlineCode",{parentName:"p"},"password")," value."),(0,r.kt)("h3",{id:"using-secrets-via-environment-variables"},"Using secrets via environment variables"),(0,r.kt)("p",null,"You can configure a secret as an environment variable for a Pod in a manifest like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"...\n  spec:\n    containers:\n    - image: mysql:5.5\n      name: dbpod\n      env:\n      - name: MYSQL_ROOT_PASSWORD\n        valueFrom:\n          secretKeyRef:\n            name: mysql\n            key: password\n")),(0,r.kt)("p",null,"There is not a limit to the number of secrets used, but a secret can only be up to 1 MB in size.  Secrets, just like any other API object, takes up memory, so with large numbers you can deplete memory on a node."),(0,r.kt)("p",null,"Secrets are stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"tmpfs")," storage on the host node, and only get sent to the host Pod.  All volumes that a Pod request must exist before containers are started, secrets are no different."),(0,r.kt)("h3",{id:"mounting-secrets-as-volumes"},"Mounting secrets as volumes"),(0,r.kt)("p",null,"Secrets can also be mounted as files using volume definitions.  The mount path contains a file with the name of the secret."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'...\n  spec:\n    containers:\n    - image: busybox\n      command:\n        - sleep\n        - "3600"\n      volumeMounts:\n      - mountPath: /mysqlpassword\n        name: mysql\n      name: busy\n    volumes:\n    - name: mysql\n        secret:\n          secretName: mysql\n')),(0,r.kt)("p",null,"Once the Pod is up and running, you can verify a secret is accessible with"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl exec -it busybox -- cat /mysqlpassword/password\n")),(0,r.kt)("h3",{id:"portable-data-with-configmaps"},"Portable data with ConfigMaps"))}p.isMDXComponent=!0},2529:function(e,t,a){t.Z=a.p+"assets/images/ch08-volumes-097df45e32ceb3ddad83983a737d6e34.png"}}]);