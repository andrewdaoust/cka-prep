"use strict";(self.webpackChunkcka_prep_2=self.webpackChunkcka_prep_2||[]).push([[4479],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=d(n),h=i,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||o;return n?a.createElement(m,l(l({ref:t},p),{},{components:n})):a.createElement(m,l({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var d=2;d<o;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9277:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return p},default:function(){return u}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),l=["components"],r={id:"chapter07",title:"Managing State with Deployments"},s=void 0,d={unversionedId:"fundamentals/chapter07",id:"fundamentals/chapter07",title:"Managing State with Deployments",description:"Course Reading",source:"@site/docs/fundamentals/chapter07.md",sourceDirName:"fundamentals",slug:"/fundamentals/chapter07",permalink:"/cka-prep/docs/fundamentals/chapter07",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fundamentals/chapter07.md",tags:[],version:"current",frontMatter:{id:"chapter07",title:"Managing State with Deployments"},sidebar:"tutorialSidebar",previous:{title:"API Objects",permalink:"/cka-prep/docs/fundamentals/chapter06"},next:{title:"Volumes and Data",permalink:"/cka-prep/docs/fundamentals/chapter08"}},p=[{value:"Course Reading",id:"course-reading",children:[{value:"Learning objectives",id:"learning-objectives",children:[],level:3},{value:"Overview",id:"overview",children:[],level:3},{value:"Deployments",id:"deployments",children:[],level:3},{value:"Object relationship",id:"object-relationship",children:[],level:3},{value:"Deployment details",id:"deployment-details",children:[],level:3},{value:"Deployment configuration metadata",id:"deployment-configuration-metadata",children:[{value:"<code>annotations</code>",id:"annotations",children:[],level:4},{value:"<code>creationTimestamp</code>",id:"creationtimestamp",children:[],level:4},{value:"<code>generation</code>",id:"generation",children:[],level:4},{value:"<code>labels</code>",id:"labels",children:[],level:4},{value:"<code>name</code>",id:"name",children:[],level:4},{value:"<code>resourceVersion</code>",id:"resourceversion",children:[],level:4},{value:"<code>uid</code>",id:"uid",children:[],level:4}],level:3},{value:"Deployment configuration spec",id:"deployment-configuration-spec",children:[{value:"<code>progressDeadlineSeconds</code>",id:"progressdeadlineseconds",children:[],level:4},{value:"<code>replicas</code>",id:"replicas",children:[],level:4},{value:"<code>revisionHistoryLimit</code>",id:"revisionhistorylimit",children:[],level:4},{value:"<code>selector</code>",id:"selector",children:[],level:4},{value:"<code>strategy</code>",id:"strategy",children:[],level:4}],level:3},{value:"Deployment configuration Pod template",id:"deployment-configuration-pod-template",children:[{value:"<code>template</code>",id:"template",children:[],level:4},{value:"<code>containers</code>",id:"containers",children:[],level:4},{value:"<code>dnsPolicy</code>",id:"dnspolicy",children:[],level:4},{value:"<code>restartPolicy</code>",id:"restartpolicy",children:[],level:4},{value:"<code>schedulerName</code>",id:"schedulername",children:[],level:4},{value:"<code>securityContext</code>",id:"securitycontext",children:[],level:4},{value:"<code>terminationGracePeriodSeconds</code>",id:"terminationgraceperiodseconds",children:[],level:4}],level:3},{value:"Deployment configuration status",id:"deployment-configuration-status",children:[],level:3},{value:"Scaling and rolling updates",id:"scaling-and-rolling-updates",children:[],level:3},{value:"Deployment rollbacks",id:"deployment-rollbacks",children:[],level:3},{value:"Using DaemonSets",id:"using-daemonsets",children:[],level:3},{value:"Labels",id:"labels-1",children:[],level:3}],level:2},{value:"Lab Exercises",id:"lab-exercises",children:[{value:"Lab 7.1 - Working with ReplicaSets",id:"lab-71---working-with-replicasets",children:[],level:3}],level:2}],c={toc:p};function u(e){var t=e.components,r=(0,i.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"course-reading"},"Course Reading"),(0,o.kt)("h3",{id:"learning-objectives"},"Learning objectives"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Discuss Deployment configuration details"),(0,o.kt)("li",{parentName:"ul"},"Scale Deployments up and down"),(0,o.kt)("li",{parentName:"ul"},"Implement rolling updates and rollback"),(0,o.kt)("li",{parentName:"ul"},"Use Labels to select various objects")),(0,o.kt)("h3",{id:"overview"},"Overview"),(0,o.kt)("p",null,"When you run ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl run"),", the default controller is a Deployment. This chapter focuses more in detail in the configuration of them.  Deployments, like other objects, can be defined in YAML or JSON, and when added to the cluster, a ReplicaSet and Pod will be created automatically.  "),(0,o.kt)("p",null,"Deployment settings can be changed via an update which will create a new ReplicaSet which will then create new Pods. Updates can be applied as a block change or via a rolling update. Most updates can be configured by editing the YAML file defining the object and then running a ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl apply"),". A ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl edit")," can also be used to modify the in-use config.  Previous ReplicaSet versions are kept in case a rollback is needed."),(0,o.kt)("p",null,"This section also focuses on labels. These are essential for Kubernetes administration, but they are not an API resource.  Labels are user defined key-value pairs attached to resources stored in the object metadata.  Tey can be used to query or select resources in the cluster, which allows for flexible and complex management. Since labels are arbitrary, you can select all resources that share a label value without having to figure out what kind or how many of these resources exist."),(0,o.kt)("h3",{id:"deployments"},"Deployments"),(0,o.kt)("p",null,"Deployments came about as enhanced versions of ReplicaControllers (RC). ReplicaControllers ensure a specified number of Pod replicas are running at any one time.  They also give the ability to perform rolling updates, however all updates are managed on the client side, which is problematic if the client loses connection which can leave the cluster in an unplanned state."),(0,o.kt)("p",null,"To avoid these issues Deployments were introduced in the ",(0,o.kt)("inlineCode",{parentName:"p"},"apps/v1")," API group.  They allow for server-side updates to Pods at specified rates.  Deployments can be used for canary and other deployment patterns. A Deployment generates a ReplicaSet, which offer more selection features than ReplicaControllers. One example is ",(0,o.kt)("inlineCode",{parentName:"p"},"matchExpressions"),"."),(0,o.kt)("p",null,"You can create a Deployment from an existing image with ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl")," like so"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create deployment dev-web --image=nginx\n")),(0,o.kt)("h3",{id:"object-relationship"},"Object relationship"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"object relationship",src:n(6370).Z,width:"656",height:"306"})),(0,o.kt)("p",null,"The diagram shows relationships between Kubernetes object.  Each of the boxes represent the controllers running as a thread of the kube-controller-manager, where each controller queries the kube-apiserver for the current state of the tracked object."),(0,o.kt)("p",null,"Walking through the diagram, we first see a Nginx container running version 1.11.  Kubernetes does not directly manage the container. Instead, the kubelet daemon checks the Pod spec by checking the runtime engine for the current status.  Next to the container we see a Pod, which is a representation of a watch loop checking the container status. The kubelet continues to compare the container spec to the response from the runtime engine, and will terminate the Pod if needed. Next to the Pod is an example of a multi-container Pod.  This works on the same principle as a single container Pod, except the watch loop needs to monitor both containers in this case."),(0,o.kt)("p",null,"Next is the ReplicaSet, which is a controller that ensured a certain number of replicas of a Pod are running. Each Pod is deployed with the same specification. If a Pod is terminated or a new one is found, the ReplicaSet will create or terminate Pods until the number of running Pods matching the specified replica count.  Since all the replicas are the same, any could be terminated should the spec demand a change in the number of running Pods."),(0,o.kt)("p",null,"Finally we have the deployment, which is a controller that manages the ReplicaSets.  They allow us to manage the version of images running in the Pods they oversee.  If a Deployment is changes, a new ReplicaSet is created, which in turn deploys new Pods using the updated podSpec. Once new Pods are running the Deployment instructs the old ReplicaSet to start terminating its Pods and eventually itself once the Pods are all shut down, and only the new ReplicaSet, with its Pods, is running."),(0,o.kt)("h3",{id:"deployment-details"},"Deployment details"),(0,o.kt)("p",null,"If you ran the command to create the ",(0,o.kt)("inlineCode",{parentName:"p"},"nginx")," deployment in the ",(0,o.kt)("a",{parentName:"p",href:"#deployments"},"Deployments")," section above you could then list the YAML or JSON output for the resources it just created like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get deployments,rs,pods -o yaml\nkubectl get deployments,rs,pods -o json\n")),(0,o.kt)("p",null,"The first few lines of the YAML response should look like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nitems:\n- apiVersion: apps/v1\n  kind: Deployment\n")),(0,o.kt)("p",null,"Let's discuss each of these lines."),(0,o.kt)("p",null,"First is the ",(0,o.kt)("inlineCode",{parentName:"p"},"apiVersion"),".  This denotes the stability of the object we ar looking at.  ",(0,o.kt)("inlineCode",{parentName:"p"},"v1")," denotes the object as stable, and it referring to the ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," type that the ",(0,o.kt)("inlineCode",{parentName:"p"},"items")," parameter defines."),(0,o.kt)("p",null,"Within the ",(0,o.kt)("inlineCode",{parentName:"p"},"items")," we see the first object has an ",(0,o.kt)("inlineCode",{parentName:"p"},"apiVersion")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"apps/v1"),", which means it is also stable.  We also see the ",(0,o.kt)("inlineCode",{parentName:"p"},"kind")," field, showing us we are looking at the specification for a ",(0,o.kt)("inlineCode",{parentName:"p"},"Deployment"),"."),(0,o.kt)("h3",{id:"deployment-configuration-metadata"},"Deployment configuration metadata"),(0,o.kt)("p",null,"Continuing from the YAML output we got from the ",(0,o.kt)("a",{parentName:"p",href:"#deployment-details"},"previous section"),", we next see the ",(0,o.kt)("inlineCode",{parentName:"p"},"metadata")," field for the deployment which looks something like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'  metadata:\n    annotations:\n      deployment.kubernetes.io/revision: "1"\n    creationTimestamp: "2022-05-10T18:21:45Z"\n    generation: 1\n    labels:\n      app: dev-web\n    name: dev-web\n    namespace: default\n    resourceVersion: "278969"\n    uid: 519529f2-6e77-4413-8df5-c498bd127e71\n')),(0,o.kt)("p",null,"This is the section that would contain any labels, annotations, or other non-configuration information.  Here's what each of the sub-parameters in the ",(0,o.kt)("inlineCode",{parentName:"p"},"metadata")," is used for:"),(0,o.kt)("h4",{id:"annotations"},(0,o.kt)("inlineCode",{parentName:"h4"},"annotations")),(0,o.kt)("p",null,"These values do not configure the object, but are helpful to provide further information for tracking or for third-party applications.  Unlike labels, annotations cannot be used for selection with ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl"),"."),(0,o.kt)("h4",{id:"creationtimestamp"},(0,o.kt)("inlineCode",{parentName:"h4"},"creationTimestamp")),(0,o.kt)("p",null,"This is the original creation time of the object. It does ",(0,o.kt)("strong",{parentName:"p"},"not")," update when the object is updated."),(0,o.kt)("h4",{id:"generation"},(0,o.kt)("inlineCode",{parentName:"h4"},"generation")),(0,o.kt)("p",null,"Is a count of how many times the object has been edited. Changing things such as the number of replicas would modify this field."),(0,o.kt)("h4",{id:"labels"},(0,o.kt)("inlineCode",{parentName:"h4"},"labels")),(0,o.kt)("p",null,"Labels are similar to annotations except they can be used for selection with ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl")," or other API calls.  This is helpful for cluster administration to select groups of different objects that may be related or for excluding other objects from queries."),(0,o.kt)("h4",{id:"name"},(0,o.kt)("inlineCode",{parentName:"h4"},"name")),(0,o.kt)("p",null,"This metadata field is a required string value. When we created the object we passed it, ",(0,o.kt)("inlineCode",{parentName:"p"},"dev-web"),".  The name must be unique to the namespace the object is a part of."),(0,o.kt)("h4",{id:"resourceversion"},(0,o.kt)("inlineCode",{parentName:"h4"},"resourceVersion")),(0,o.kt)("p",null,"This is a value tied to the etcd database to help with object concurrency.  Changes to the database cause this number to change."),(0,o.kt)("h4",{id:"uid"},(0,o.kt)("inlineCode",{parentName:"h4"},"uid")),(0,o.kt)("p",null,"A unique ID for the life of the object."),(0,o.kt)("p",null,"Also, it should be noted that the output will not include every configuration setting, as many are set to false by default and therefore are not shown, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"podAffinity")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"nodeAffinity"),"."),(0,o.kt)("h3",{id:"deployment-configuration-spec"},"Deployment configuration spec"),(0,o.kt)("p",null,"Continuing on down the output, we next see the ",(0,o.kt)("inlineCode",{parentName:"p"},"spec")," section. There a two ",(0,o.kt)("inlineCode",{parentName:"p"},"spec")," declarations for a deployment, the first is for ReplicaSet, and the second for the Pod.  The first one looks like this in the output from previously."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"  spec:\n    progressDeadlineSeconds: 600\n    replicas: 1\n    revisionHistoryLimit: 10\n    selector:\n      matchLabels:\n        app: dev-web\n    strategy:\n      rollingUpdate:\n        maxSurge: 25%\n        maxUnavailable: 25%\n      type: RollingUpdate\n")),(0,o.kt)("h4",{id:"progressdeadlineseconds"},(0,o.kt)("inlineCode",{parentName:"h4"},"progressDeadlineSeconds")),(0,o.kt)("p",null,"This is the time until a progress error is reported when a change occurs.  These errors could happen for a variety of reasons, such as quotas, image issues, or limit ranges."),(0,o.kt)("h4",{id:"replicas"},(0,o.kt)("inlineCode",{parentName:"h4"},"replicas")),(0,o.kt)("p",null,"Since this ",(0,o.kt)("inlineCode",{parentName:"p"},"spec")," defines a ReplicaSet, this parameter is needed to determine how many replicas of a Pod the ReplicaSet needs to ensure. If you changes the replicas to 2 with a ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl edit"),", a second Pod would be spun up."),(0,o.kt)("h4",{id:"revisionhistorylimit"},(0,o.kt)("inlineCode",{parentName:"h4"},"revisionHistoryLimit")),(0,o.kt)("p",null,"This is the number of old ReplicaSet specifications that are retained in case a rollback is needed."),(0,o.kt)("h4",{id:"selector"},(0,o.kt)("inlineCode",{parentName:"h4"},"selector")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"selector")," field is a collection of values ANDed together. All must be satisfied for the replica to match.  Do not create a Pod that matches these selectors as the Deployment controller could potentially try to control these resource, leading to issues."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"matchLabels")," sub-parameter define set-based requirements for the Pod selector.  This is often paired with the ",(0,o.kt)("inlineCode",{parentName:"p"},"matchExpressions")," statement as well to further define where resources should be scheduled."),(0,o.kt)("h4",{id:"strategy"},(0,o.kt)("inlineCode",{parentName:"h4"},"strategy")),(0,o.kt)("p",null,"The strategy section defines values regarding updates for Pods. It works with the later defined ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," field which specifies the strategy for updating Pods. In the case of the example, it is a ",(0,o.kt)("inlineCode",{parentName:"p"},"RollingUpdate"),", which has other parameters that can be defined to control the number of Pods deleted at a time.  Even through it is defined last here, it is what is read to determine the object being configured."),(0,o.kt)("p",null,"For a ",(0,o.kt)("inlineCode",{parentName:"p"},"RollingRestart")," we can define ",(0,o.kt)("inlineCode",{parentName:"p"},"maxSurge")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"maxUnavailable")," fields.  The ",(0,o.kt)("inlineCode",{parentName:"p"},"maxSurge")," parameter defines the number of Pods that can be created above the desired limit.  It can be a percentage, like the default 25% here, or an absolute number.  This creates a certain number of new Pods before deleting any old ones for continued access to the running application.  The ",(0,o.kt)("inlineCode",{parentName:"p"},"maxUnavailable")," field is the configured number or percentage of Pods that can be in a state other than ",(0,o.kt)("inlineCode",{parentName:"p"},"Ready")," during the update process."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"strategy")," could also be set to ",(0,o.kt)("inlineCode",{parentName:"p"},"Recreate")," which would delete all existing Pods before creating any new ones."),(0,o.kt)("h3",{id:"deployment-configuration-pod-template"},"Deployment configuration Pod template"),(0,o.kt)("p",null,"Next is the ",(0,o.kt)("inlineCode",{parentName:"p"},"template")," section, which is actually contained within the ",(0,o.kt)("inlineCode",{parentName:"p"},"spec")," section we discussed about ",(0,o.kt)("a",{parentName:"p",href:"#deployment-configuration-spec"},"above"),". it looks something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"    template:\n      metadata:\n        creationTimestamp: null\n        labels:\n          app: dev-web\n      spec:\n        containers:\n        - image: nginx:1.13.7-alpine\n          imagePullPolicy: IfNotPresent\n          name: nginx\n          resources: {}\n          terminationMessagePath: /dev/termination-log\n          terminationMessagePolicy: File\n        dnsPolicy: ClusterFirst\n        restartPolicy: Always\n        schedulerName: default-scheduler\n        securityContext: {}\n        terminationGracePeriodSeconds: 30\n")),(0,o.kt)("p",null,"This is the template used for each of the Pods to be deployed. Again, let's break down each section."),(0,o.kt)("h4",{id:"template"},(0,o.kt)("inlineCode",{parentName:"h4"},"template")),(0,o.kt)("p",null,"The template header defines the configuration that is passed to the ReplicaSet for how to deploy an object (in this case Pods/containers)."),(0,o.kt)("p",null,"We again see a ",(0,o.kt)("inlineCode",{parentName:"p"},"metadata")," section which serves the same function ",(0,o.kt)("a",{parentName:"p",href:"#deployment-configuration-metadata"},"as discussed here"),"."),(0,o.kt)("h4",{id:"containers"},(0,o.kt)("inlineCode",{parentName:"h4"},"containers")),(0,o.kt)("p",null,"This keyword indicates the following items of the array are specification for the containers that will be deployed in the Pod. Each container has some more keywords to configure."),(0,o.kt)("p",null,"The first is ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"image")),", which is the name of the image passed to the container runtime engine.  The engine pulls the image and creates the Pod."),(0,o.kt)("p",null,"We also define an ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"imagePullPolicy"))," to define when and if an image should be downloaded or if the locally cached image should be used. This can take three values. ",(0,o.kt)("inlineCode",{parentName:"p"},"IfNotPresent")," pulls the image only if it is not present locally.  ",(0,o.kt)("inlineCode",{parentName:"p"},"Always")," will make the kubelet alway query the container registry to pull the image before launching a new one. ",(0,o.kt)("inlineCode",{parentName:"p"},"Never")," will make the kubelet never pull the image, which causes startup to fail if the image is not present locally already."),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"name"))," field denoted the stub of the Pod name, with a unique string being appended to the end."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"resources"))," by default are empty.  This is where any resource restrictions or limits, like for CPU or memory, would be configured for the containers."),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"terminationMessagePath"))," defines the location where to output success or failure information from a container. The ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"terminationMessagePolicy"))," holds the termination method.  The default is ",(0,o.kt)("inlineCode",{parentName:"p"},"File"),", but it can also be set to ",(0,o.kt)("inlineCode",{parentName:"p"},"FallbackToLogsOnError")," which uses the last chunk of container logs if the message file is empty and the container is showing an error."),(0,o.kt)("h4",{id:"dnspolicy"},(0,o.kt)("inlineCode",{parentName:"h4"},"dnsPolicy")),(0,o.kt)("p",null,"This determines is the DNS queries should go through ",(0,o.kt)("strong",{parentName:"p"},"coredns"),".  If set to ",(0,o.kt)("inlineCode",{parentName:"p"},"Default"),", the node's DNS resolution configuration is used."),(0,o.kt)("h4",{id:"restartpolicy"},(0,o.kt)("inlineCode",{parentName:"h4"},"restartPolicy")),(0,o.kt)("p",null,"This defines is containers should be restarted if killed.  Automatic restarts are part of the usual strength of Kubernetes."),(0,o.kt)("h4",{id:"schedulername"},(0,o.kt)("inlineCode",{parentName:"h4"},"schedulerName")),(0,o.kt)("p",null,"This allows for the use of a custom scheduler if you don't want to use the Kubernetes default."),(0,o.kt)("h4",{id:"securitycontext"},(0,o.kt)("inlineCode",{parentName:"h4"},"securityContext")),(0,o.kt)("p",null,"A flexible setting to pass one or many security settings. These could include SELinux context, AppArmor values, users, and UIDs for the containers to use."),(0,o.kt)("h4",{id:"terminationgraceperiodseconds"},(0,o.kt)("inlineCode",{parentName:"h4"},"terminationGracePeriodSeconds")),(0,o.kt)("p",null,"Sets the amount of time to wait for a ",(0,o.kt)("inlineCode",{parentName:"p"},"SIGTERM")," to run before a ",(0,o.kt)("inlineCode",{parentName:"p"},"SIGKILL")," is used to terminate the container."),(0,o.kt)("h3",{id:"deployment-configuration-status"},"Deployment configuration status"),(0,o.kt)("p",null,"Now, let's take a look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"status")," section of the output for our Deployment object."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'  status:\n    availableReplicas: 1\n    conditions:\n    - lastTransitionTime: "2022-05-10T18:21:47Z"\n      lastUpdateTime: "2022-05-10T18:21:47Z"\n      message: Deployment has minimum availability.\n      reason: MinimumReplicasAvailable\n      status: "True"\n      type: Available\n    - lastTransitionTime: "2022-05-10T18:21:45Z"\n      lastUpdateTime: "2022-05-10T18:21:47Z"\n      message: ReplicaSet "dev-web-565cb67bd6" has successfully progressed.\n      reason: NewReplicaSetAvailable\n      status: "True"\n      type: Progressing\n    observedGeneration: 1\n    readyReplicas: 1\n    replicas: 1\n    updatedReplicas: 1\n')),(0,o.kt)("p",null,"Some sections to note in the ",(0,o.kt)("inlineCode",{parentName:"p"},"status")," are the ",(0,o.kt)("inlineCode",{parentName:"p"},"availableReplicas")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"observedGeneration")," fields.  The ",(0,o.kt)("inlineCode",{parentName:"p"},"availableReplicas")," indicates how many replicas were configured by the ReplicaSet.  This is then later compared to ",(0,o.kt)("inlineCode",{parentName:"p"},"readyReplicas")," to determine if all have been fully created without error."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"observedGeneration")," parameter shows how often the deployment has been updated, which can be used to understand the rollout and rollback situation of the deployment."),(0,o.kt)("h3",{id:"scaling-and-rolling-updates"},"Scaling and rolling updates"),(0,o.kt)("p",null,"The kube-apiserver allows most configuration settings to be updated, however there are some that are immutable which can differ depending on the version of Kubernetes deployed."),(0,o.kt)("p",null,"A more common update is scaling the number of replicas for a Deployment.  You could in theory also scale a Deployment to 0 replicas, leaving just a ReplicaSet and a Deployment, which behind the scenes is what happens when a Deployment is deleted. As an example, let's scale the Nginx deployment we created earlier."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl scale deploy/dev-web --replicas=4\n")),(0,o.kt)("p",null,"For immutable values, we can edit the deployment and trigger an update.  Again, using the example of our Nginx deployment we could do"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl edit deployment dev-web\n")),(0,o.kt)("p",null,"This would open up a text editor and you could make a change, like for example the image version."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"...\n      containers:\n      - image: nginx:1.8   # <-- Update this to an older version\n        imagePullPolicy: IfNotPresent\n        name: nginx\n...\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"edit")," command then triggers the update of the Deployment. While the Deployment shows its age as the original creation time, inspecting the Pods would show that they had been recently created."),(0,o.kt)("h3",{id:"deployment-rollbacks"},"Deployment rollbacks"),(0,o.kt)("p",null,"Some previous ReplicaSets and Deployments are kept in the case a rollback is needed.  The number kept is configurable and changes version to version.  Let's take a loot at how rollbacks can be made."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create deploy ghost --image=ghost\nkubectl get deploy ghost -o yaml\n")),(0,o.kt)("p",null,"This is what the deployment should look like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  annotations:\n    deployment.kubernetes.io/revision: "1"\n  creationTimestamp: "2022-05-11T16:17:57Z"\n  generation: 1\n  labels:\n    app: ghost\n  name: ghost\n  namespace: default\n  resourceVersion: "296422"\n  uid: 985f8c5a-8040-4c00-81b9-833dd03bde0a\nspec:\n  progressDeadlineSeconds: 600\n  replicas: 1\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: ghost\n  strategy:\n    rollingUpdate:\n      maxSurge: 25%\n      maxUnavailable: 25%\n    type: RollingUpdate\n  template:\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: ghost\n    spec:\n      containers:\n      - image: ghost\n        imagePullPolicy: Always\n        name: ghost\n        resources: {}\n        terminationMessagePath: /dev/termination-log\n        terminationMessagePolicy: File\n      dnsPolicy: ClusterFirst\n      restartPolicy: Always\n      schedulerName: default-scheduler\n      securityContext: {}\n      terminationGracePeriodSeconds: 30\nstatus:\n  availableReplicas: 1\n  conditions:\n  - lastTransitionTime: "2022-05-11T16:18:15Z"\n    lastUpdateTime: "2022-05-11T16:18:15Z"\n    message: Deployment has minimum availability.\n    reason: MinimumReplicasAvailable\n    status: "True"\n    type: Available\n  - lastTransitionTime: "2022-05-11T16:17:57Z"\n    lastUpdateTime: "2022-05-11T16:18:15Z"\n    message: ReplicaSet "ghost-5c7f765cdc" has successfully progressed.\n    reason: NewReplicaSetAvailable\n    status: "True"\n    type: Progressing\n  observedGeneration: 1\n  readyReplicas: 1\n  replicas: 1\n  updatedReplicas: 1\n')),(0,o.kt)("p",null,"If an update were to fail, you can roll back to a previous version with a ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl rollout undo")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl set image deployment/ghost ghost=ghost:09 --all\nkubectl rollout history deployment/ghost\nkubectl get pods\n")),(0,o.kt)("p",null,"When getting the Pods, you should see the new ",(0,o.kt)("inlineCode",{parentName:"p"},"ghost")," Pod is erroring, likely with a ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrImagePull")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"ImagePullBackOff")," status since the tag we specified on the image was bad."),(0,o.kt)("p",null,"To fix this we can undo the change."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl rollout undo deployment/ghost\nkubectl get pods\n")),(0,o.kt)("p",null,"You should then see the ",(0,o.kt)("inlineCode",{parentName:"p"},"ghost")," Pod working normally again.  You can also specify a specific revision to roll back to using the ",(0,o.kt)("inlineCode",{parentName:"p"},"--to-revision=")," flag and specifying the revision number from the ",(0,o.kt)("inlineCode",{parentName:"p"},"rollout history")," command."),(0,o.kt)("p",null,"Deployments can be paused and resumes as well with"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl rollout pause deployment/ghost\nkubectl rollout resume deployment/ghost\n")),(0,o.kt)("p",null,"ReplicationControllers can have rolling updates applied with ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl rolling-update")," command, but as mentioned before, this is done on the client side. So if a connection is lost the update will stop."),(0,o.kt)("h3",{id:"using-daemonsets"},"Using DaemonSets"),(0,o.kt)("p",null,"A newer object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"DaemonSet"),", which ensures a single Pod is running on each cluster node.  Every Pod the DaemonSet manages uses the same image, and when new nodes are added, the controller will deploy a new, identical Pod on it. If the node is removed, the controller will also delete the Pod first."),(0,o.kt)("p",null,"DaemonSets are useful in that it ensured a particular container is always running on every node, which in a large dynamic environment is helpful so an administrator does not always need to remember to deploy certain things, like for example a logging or metric generation application."),(0,o.kt)("p",null,"There are ways to effect the kube-apiserver so that DaemonSets do not run on certain nodes."),(0,o.kt)("h3",{id:"labels-1"},"Labels"),(0,o.kt)("p",null,"Labels are an important tool for cluster administration.  They can be used for selection using an arbitrary string regardless of the object type.  Labels are immutable as of ",(0,o.kt)("inlineCode",{parentName:"p"},"apps/v1"),"."),(0,o.kt)("p",null,"Any resource can contain labels in its metadata. By default, when you use ",(0,o.kt)("inlineCode",{parentName:"p"},"kubectl create")," to launch a Deployment, some labels are added."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"...\n  labels:\n    app: ghost\n    pod-template-hash: 5c7f765cdc\n...\n")),(0,o.kt)("p",null,"Here are some examples of using and adding labels."),(0,o.kt)("p",null,"For example, you could get Pod with the label ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," and a value of ",(0,o.kt)("inlineCode",{parentName:"p"},"ghost"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -l app=ghost\n")),(0,o.kt)("p",null,"Or you could get all the Pods with the ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," label and list their values as another column like so."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -L app\n")),(0,o.kt)("p",null,"Labels are usually defined in Pod templates in Deployment spec but you can also add them on the fly."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl label pods ghost-<uid> foo=bar\n")),(0,o.kt)("p",null,"And you can show the labels on each pod with a ",(0,o.kt)("inlineCode",{parentName:"p"},"get")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods --show-labels\n")),(0,o.kt)("h2",{id:"lab-exercises"},"Lab Exercises"),(0,o.kt)("h3",{id:"lab-71---working-with-replicasets"},"Lab 7.1 - Working with ReplicaSets"))}u.isMDXComponent=!0},6370:function(e,t,n){t.Z=n.p+"assets/images/ch07-obj-relationship-79ce6aac35c486207615483ff9248c5b.png"}}]);